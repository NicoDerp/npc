#!/usr/bin/python3

import sys, os, re
import subprocess
import time
import warnings


# Help message
help_message ="""\
Usage: npc <file> [options]

Options:
  -o <file>    Place the output into file
  -S           Do not assemble, output is assembly code
  -r           Run the program after a succesful compilation
  -dO          Disable optimization
  --unsafe     Disable type-checking
  --help       Display this information and exit"""

# To catch DeprecationWarning
warnings.filterwarnings("error")

class Arguments:
	def __init__(self):
		self.infn = None
		self.outfn = 'a.out'
		self.help = None
		self.none = None
		self.asm = None
		self.run = None
		self.include_path = './'
		self.unsafe = False
		self.disOpt = False
		
class Classified:
	def __init__(self, type):
		self.type = type

class Position():
	def __init__(self, tok):
		self.row = tok.row
		self.col = tok.col
		self.filepath = tok.filepath
		self.tok = tok

	def pos(self):
		row = self.row
		row += 1 if row != 0 else 0  # Since emacs is dum dum
		return f"{self.filepath}:{row}:{self.col}"
		
class Const(Classified, Position):
	def __init__(self, value_type, value, tok):
		Classified.__init__(self, "CONST")
		Position.__init__(self, tok)
		self.value_type = value_type
		self.value = value

class Keyword(Classified, Position):
	def __init__(self, op, tok):
		Classified.__init__(self, "KEYWORD")
		Position.__init__(self, tok)
		self.op = op

class Word(Classified, Position):
	def __init__(self, op, tok):
		Classified.__init__(self, "WORD")
		Position.__init__(self, tok)
		self.op = op
		
class Macro(Classified, Position):
	def __init__(self, body, name, tok):
		Classified.__init__(self, "MACRO")
		Position.__init__(self, tok)
		self.body = body
		self.name = name

class MacroCall(Classified, Position):
	def __init__(self, tok):
		Classified.__init__(self, "MACRO_CALL")
		Position.__init__(self, tok)
		self.name = tok.token

class ProcCall(Classified, Position):
	def __init__(self, macro, procs):
		Classified.__init__(self, "PROC_CALL")
		Position.__init__(self, macro.tok)
		self.index = procs[macro.name]['index']
		self.name = macro.name

class Token(Position):
	def __init__(self, token, row, col, filepath):
		self.token = token
		self.row = row
		self.col = col
		self.filepath = filepath

class Depth():
	def __init__(self, depth):
		self.counter = 0
		self.depth = depth
		self.loop = False

	def label(self):
		return f".L{self.depth}.{self.counter}"

	def nextLabel(self):
		self.counter += 1
		return f".L{self.depth}.{self.counter}"


def program_error(word, err):
	row = word.row
	row += 1 if word.row != 0 else 0  # Since emacs is dum dum
	print(f"{word.pos()}: error: {err}")
	exit(1)

def program_error_(word, err):
	row = word.row
	row += 1 if word.row != 0 else 0  # Since emacs is dum dum
	print(f"{word.pos()}: error: {err}")

	
def program_note(word, note):
	row = word.row
	row += 1 if word.row != 0 else 0  # Since emacs is dum dum
	print(f"{word.pos()}: note: {note}")

def compiler_error(err):
	print(err)
	exit(1)

def did_you_mean(s, l):
	ml = []
	for match in l:
		# Insert
		changes = abs(len(match) - len(s))
		for c1, c2 in zip(s, match):
			if c1 != c2:
				changes += 1
		# Substitute
		if len(ml) == 0:
			ml.append((changes, match))
		elif len(ml) >= 1:
			for c, m in ml:
				if changes < c:
					ml = [(changes, match)]
					break
				elif changes == c:
					ml.append((changes, match))
					break
	return ml

def lex_file(source_file):
	# Read and get tokens (not including comments)
	with open(source_file, 'r') as infile:
		# Comments!
		lines = [line.split('//', 1)[0] for line in infile.readlines()]
		matches = [((token.start(), token.group()) for token in re.finditer(r"\"((.|\\.)+?)\"(c)?|'(.+?)'|\S+", line)) for line in lines]
		
	for row, i in enumerate(matches):
		for col, tok in i:
			#print(f"Row: {row}, Col: {col}, Token: {tok}")
			yield Token(tok, row, col, source_file)

def parse_string(tok):
	# Only one character so def no string
	if len(tok.token) == 1:
		program_error(tok, f"unclosed string literal `{tok.token}`")

	cstr = tok.token[-1] == 'c'
	
	quote = tok.token[0]
	# Not a quote (shouldn't occur)
	if not quote in '\'"':
		program_error(tok, f"unclosed string literal `{tok.token}`")

	# Two different quotes
	if not cstr and quote != tok.token[-1] or cstr and quote != tok.token[-2]:
		program_error(tok, f"unclosed string literal `{tok.token}`")
	
	# Remove quotes
	if cstr:
		s = tok.token[1:-2]
	else:
		s = tok.token[1:-1]
	
	# For escaped stuff, convert to bytes, then back again
	bytes_string = bytes(s, 'utf-8')
	try:
		s = bytes_string.decode('unicode_escape')
	except (UnicodeDecodeError, DeprecationWarning):
		program_error(tok, "invalid escape sequence in string")
	
	# String
	if quote == '"':
		str_type = 'CSTR' if cstr else 'STR'
		return Const(str_type, s, tok)
	
	# Character
	if len(s) != 1:
		program_error(tok, f"only a single byte is allowed inside a character literal")

	return Const('CHAR', hex(ord(s)), tok)
			
def parse(tokens):
	while True:
		try:
			tok = next(tokens)
		except StopIteration:
			break
		
		if tok.token == '+':
			yield Word('ADD', tok)

		elif tok.token == '-':
			yield Word('SUB', tok)

		elif tok.token == '*':
			yield Word('MULT', tok)

		elif tok.token == '/':
			yield Word('DIV', tok)

		elif tok.token == '/%':
			yield Word('DIVMOD', tok)
		
		elif tok.token == 'argv':
			yield Word('ARGV', tok)

		elif tok.token == 'argc':
	   		yield Word('ARGC', tok)
			
		elif tok.token == 'bor':
			yield Word('BINARY_OR', tok)

		elif tok.token == 'band':
			yield Word('BINARY_AND', tok)

		elif tok.token == 'lor':
			yield Word('LOGICAL_OR', tok)

		elif tok.token == 'land':
			yield Word('LOGICAL_AND', tok)

		elif tok.token == 'shl':
			yield Word('SHIFT_LEFT', tok)

		elif tok.token == 'shr':
			yield Word('SHIFT_RIGHT', tok)

		elif tok.token == 'dump':
			yield Word('DUMP', tok)

		elif tok.token == '=':
			yield Word('EQU', tok)

		elif tok.token == '!=':
			yield Word('NOT_EQU', tok)

		elif tok.token == 'dup':
			yield Word('DUP', tok)

		elif tok.token == '2dup':
			yield Word('2DUP', tok)

		elif tok.token == 'swap':
			yield Word('SWAP', tok)

		elif tok.token == 'drop':
			yield Word('DROP', tok)

		elif tok.token == 'over':
			yield Word('OVER', tok)

		elif tok.token == 'rot':
			yield Word('ROT', tok)

		elif tok.token == '>':
			yield Word('GREATER_THAN', tok)

		elif tok.token == '<':
			yield Word('LESS_THAN', tok)

		elif tok.token == 'mem':
			yield Word('MEM', tok)

		elif tok.token == ',':
			yield Word('LOAD', tok)

		elif tok.token == '.':
			yield Word('STORE', tok)

		elif tok.token == ',64':
			yield Word('LOAD64', tok)

		elif tok.token == '.64':
			yield Word('STORE64', tok)

		elif tok.token == 'syscall0':
			yield Word('SYSCALL0', tok)
		
		elif tok.token == 'syscall1':
			yield Word('SYSCALL1', tok)

		elif tok.token == 'syscall2':
			yield Word('SYSCALL2', tok)
		
		elif tok.token == 'syscall3':
			yield Word('SYSCALL3', tok)

		elif tok.token == 'syscall4':
			yield Word('SYSCALL4', tok)
		
		elif tok.token == 'syscall6':
			yield Word('SYSCALL6', tok)
		
		elif tok.token == 'cast(int)':
			yield Word('CAST_INT', tok)

		elif tok.token == 'cast(ptr)':
			yield Word('CAST_PTR', tok)

		elif tok.token == 'cast(bool)':
			yield Word('CAST_BOOL', tok)

		elif tok.token == 'proc':
			yield Keyword('PROC', tok)

		elif tok.token == '--':
			yield Keyword('PROC_BAR', tok)

		elif tok.token == 'in':
			yield Keyword('PROC_IN', tok)

		elif tok.token == 'int':
			yield Keyword('PROC_INT', tok)

		elif tok.token == 'ptr':
			yield Keyword('PROC_PTR', tok)

		elif tok.token == 'bool':
			yield Keyword('PROC_BOOL', tok)
		
		elif tok.token == 'if':
			yield Keyword('IF', tok)

		elif tok.token == 'elif':
			yield Keyword('ELIF', tok)
		
		elif tok.token == 'else':
			yield Keyword('ELSE', tok)

		elif tok.token == 'end':
			yield Keyword('END', tok)

		elif tok.token == 'while':
			yield Keyword('WHILE', tok)

		elif tok.token == 'do':
			yield Keyword('DO', tok)

		elif tok.token == 'include':
			yield Keyword('INCLUDE', tok)

		elif tok.token == 'macro':
			yield Keyword('MACRO', tok)

		elif tok.token == 'memory':
			yield Keyword('MEMORY', tok)
		
		else:
			if '\'' in tok.token or '\"' in tok.token:
				yield parse_string(tok)
			else:
				try:
					yield Const('INT', int(tok.token), tok)
				except ValueError as err:
					yield MacroCall(tok)
			#program_error(tok, err)

	
def parse_args():
	argv = iter(sys.argv)
	arguments = Arguments() # Put default values here

	# No arguments so skip and save
	if len(sys.argv) == 1:
		arguments.none = True
		return arguments

	# Since the first one is npc, the second is the file name
	next(argv)

	first = next(argv)
	if first == '--help':
		arguments.help = True
		return arguments

	arguments.infn = first

	while True:
		try:
			arg = next(argv)
		except:
			break

		# print("Arg:", arg)

		if arg == '-S':
			arguments.asm = True

		elif arg == '-r':
			arguments.run = True

		elif arg == '--unsafe':
			arguments.unsafe = True

		elif arg == '-dO':
			arguments.disOpt = True
		
		elif arg == '-o':
			try:
				arg = next(argv)
			except:
				compiler_error("ERROR: failed to parse args, missing filename after '-o'")

			arguments.outfn = arg

		elif arg == '-I':
			try:
				arg = next(argv)
			except:
				compiler_error("ERROR: failed to parse args, missing path after '-I'")
			
			arguments.include_path = arg
			
		# Unreckgnised argument
		else:
			compiler_error(f"ERROR: unreckognized argument '{arg}'")

	return arguments

def format_word(typ, word):
	if word.type == 'KEYWORD':
		return f"{typ} from keyword {word.op}"

	elif word.type == 'WORD':
		return f"{typ} from word {word.op}"

	elif word.type == 'CONST':
		return f"{typ} from const"

	elif word.type == 'PROC_CALL':
		return f"{typ} from proc {word.name}"

	else:
		return f'unknown {word.type}'
	
def preprocess(words, args, includes=0, expansions=0, macros={}, memories={}, memOffset=[0], insideProc=0):
	#print("Preprocessing with memOffset:", memOffset)
	while True:
		try:
			word = next(words)
		except StopIteration:
			break
		
		if word.type == 'KEYWORD' and word.op == 'PROC':
			insideProc = 1

		if insideProc == 2 and word.type == 'KEYWORD' and word.op == 'END':
			insideProc = 0

		if insideProc != 0 and word.type == 'KEYWORD' and word.op == 'END':
			insideProc -= 1
		if insideProc != 0 and word.type == 'KEYWORD' and word.op in ["IF", "WHILE"]:
			insideProc += 1
		if word.type == 'KEYWORD' and word.op == 'INCLUDE':
			if includes >= 5:
				program_error(next(words), f"recursive include limit reached: `{includes}`")

			if insideProc >= 2:
				program_error(word, "includes are not allowed inside procedures")
	
			inc = next(words)
			if inc.type != 'CONST' or inc.value_type != 'STR':
				program_error(inc, f'expected string to include got \'{inc.type}\'')
			fileName = os.path.join(args.include_path, inc.value)
			if not os.path.exists(fileName):
				program_error(inc, f"couldn't include file `{fileName}` because it does not exist! Double check the name and include paths.")

			#print("include: Calling preprocess with memoffset", memOffset)
			for w in preprocess((parse(lex_file(fileName))), args=args, includes=includes+1, expansions=expansions, macros=macros, memories=memories, memOffset=memOffset, insideProc=insideProc):
				yield w

		elif word.type == 'KEYWORD' and word.op == 'MACRO':
			if expansions >= 5:
				program_error(next(words), f"recursive expansions limit reached: `{expansions}`")

			if insideProc >= 2:
				program_error(word, "macro definition is not allowed inside procedures")

			body = []
			depth = 1
			
			name = next(words)
			if name.type != 'MACRO_CALL':
				program_error(name, f"wrong type for macro name. Expected `MACRO_CALL`, but got `{name.type}")

			if name.name in macros.keys():
				program_error_(word, f"redefinition of already existing macro `{name.name}`")
				program_note(macros[name.name][1], f"the first definition is located here")
				exit(1)

			if name.name in memories.keys():
				program_error_(word, f"redefinition of already existing memory `{name.name}`")
				program_note(memory[name.name][1], f"the first definition is located here")
				exit(1)
				
			while True:
				try:
					w = next(words)
				except StopIteration:
					program_error(word, '`macro` word is missing `end`')
				
				if w.type == 'KEYWORD' and w.op in ['IF', 'WHILE', 'PROC']:
					depth += 1
					
				if w.type == 'KEYWORD' and w.op == 'END':
					depth -= 1

				if depth == 0:
					break

				body.append(w)

			#print("expansions: Calling preprocess with memoffset", memOffset)
			body = list(preprocess((x for x in body), args=args, includes=includes, expansions=expansions+1, macros=macros, memories=memories, memOffset=memOffset, insideProc=insideProc))
			
			macros[name.name] = (body, word)
			
		elif word.type == 'MACRO_CALL':
			if insideProc == 1:
				insideProc = 2
				yield word
				continue
			
			if word.name in macros.keys():
				for w in macros[word.name][0]:
					yield w

			elif word.name in memories.keys():
				#yield memories[word.name][0]
				yield Const("MEMORY_OFFSET", memories[word.name], word)
			else:
				yield word
				continue
				
		elif word.type == 'KEYWORD' and word.op == 'MEMORY':
			try:
				name = next(words)
			except StopIteration:
				program_error(word, "memory definition is missing end")

			if name.type != 'MACRO_CALL':
				program_error(name, f"wrong type for memory name. Expected `MACRO_CALL`, but got `{name.type}")
			
			if name.name in memories.keys():
				program_error_(word, f"redefinition of already existing memory `{name.name}`")
				program_note(memories[name.name][1], f"the first definition is located here")
				exit(1)

			if name.name in macros.keys():
				program_error_(word, f"redefinition of already existing macro `{name.name}`")
				program_note(macros[name.name][1], f"the first definition is located here")
				exit(1)

			stack = []
				
			while True:
				try:
					w = next(words)
				except StopIteration:
					program_error(word, "memory is missing end")

				if w.type == 'KEYWORD':
					if w.op == 'END':
						break
					else:
						program_error_(w, "keywords are not allowed in memory reservation")
						program_note(word, "memory definition")
						exit(1)
				elif w.type == 'CONST':
					if w.value_type == 'INT':
						stack.append(w.value)
					elif w.value_type == 'STRING':
						program_error_(w, "strings are not allowed in memory reservation")
						program_note(word, "memory definition")
						exit(1)
					elif w.value_type == 'CHARACTER':
						program_error_(w, "characters are not allowed in memory reservation")
						program_note(word, "memory definition")
						exit(1)
					else:
						program_error(w, "shouldn't get here??")

				elif w.type == 'WORD':
					if w.op == 'ADD':
						if len(stack) < 2:
							not_enough_arguments(w)
						a = stack.pop()
						b = stack.pop()
						stack.append(a+b)
					elif w.op == 'SUB':
						if len(stack) < 2:
							not_enough_arguments(w)
						a = stack.pop()
						b = stack.pop()
						stack.append(b-a)
					elif w.op == 'MULT':
						if len(stack) < 2:
							not_enough_arguments(w)
						a = stack.pop()
						b = stack.pop()
						stack.append(a*b)
					else:
						print(w.op)
						program_error_(w, "only addition, subtraction and multiplication are allowed in memory reservation")
						program_note(word, "memory definition")
						exit(1)

				elif w.type == 'MACRO_CALL':
					if w.name in macros.keys():
						# TODO: preprocess maybe
						m = macros[w.name]
						mbody = list(preprocess((x for x in m[0]), args=args, includes=includes, expansions=expansions+1, macros=macros, memories=memories, memOffset=memOffset, insideProc=insideProc))
						if len(mbody) != 1:
							program_error_(w, "only macros with an integer constant are currently allowed inside a memory reservation")
							program_note(m[1], "macro definition")
							exit(1)
						o = mbody.pop()
						if o.type != 'CONST' or o.type == 'CONST' and o.value_type != 'INT':
							program_error_(w, "only macros with an integer constant are currently allowed inside a memory reservation")
							program_note(m[1], "macro definition")
							program_note(o, "not const")
							exit(1)
						stack.append(o.value)
					elif w.name in memories.keys():
						stack.append(memories[w.name][0])
					else:
						program_error(word, f"macro or memory `{word.name}` does not exist or is used inside it's definition")
						
				else:
					program_error_(w, "illegal type in memery reservation")
					program_note(word, "memory definition")
					exit(1)
						
			if len(stack) > 1:
				program_error(word, "more than one number in stack")

			if len(stack) == 0:
				program_error(word, "no size spesified")

			#print("Memory size reserved:", stack[0])
			
			size = stack.pop()
			if size <= 0:
				program_error(word, "no numbers less than 1 allowed in memory reservation")
			memories[name.name] = [size, memOffset[0]]
			#print("Assignign offset", memOffset[0], "to", name.name)
			memOffset[0] += size
			
		else:
			yield word

def not_enough_arguments(word):
	program_error(word, f"not enough arguments for operation `{word.op}`")

def invalid_arguments(word, expected, got):
	program_error(word, f"invalid argument types for {word.op} operation. Expected {expected} but got {got}")

def expected_vs_actual(end, expected, actual):
	print("\nExpected types:")
	for typ, word in expected:
		program_note(word, format_word(typ, word))
	
	print("\nActual types:")
	for typ, word in actual:
		program_note(word, format_word(typ, word))

	exit(1)

def typecheck_words(words, stack, procs={}, checkingProc=False):
	block_stack: List[Tuple[List[Tuple[String, Word]], Keyword]] = []
	for word in words:
		if word.type == 'CONST':
			if word.value_type == 'INT':
				stack.append(('INT', word))

			elif word.value_type == 'STR':
				stack.append(('INT', word))
				stack.append(('PTR', word))

			elif word.value_type == 'CSTR':
				stack.append(('PTR', word))

			elif word.value_type == 'CHAR':
				stack.append(('INT', word))

			elif word.value_type == 'MEMORY_OFFSET':
				stack.append(('PTR', word))
				
			else:
				program_error(word, f"unknown const type `{word.value_type}`")

		elif word.type == 'WORD':
			if word.op == 'ADD':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()
				
				if a_type == 'INT' and b_type == 'INT':
					stack.append(('INT', word))
				elif a_type == 'PTR' and b_type == 'INT':
					stack.append(('PTR', word))
				elif a_type == 'INT' and b_type == 'PTR':
					stack.append(('PTR', word))
				else:
					invalid_arguments(word, '`INT` or `PTR`', f'`{a_type}` and `{b_type}`')
					
			elif word.op == 'SUB':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type == 'INT' and b_type == 'INT':
					stack.append(('INT', word))
				elif a_type == 'PTR' and b_type == 'INT':
					stack.append(('PTR', word))
				elif a_type == 'INT' and b_type == 'PTR':
					stack.append(('PTR', word))
				else:
					invalid_arguments(word, '`INT` or `PTR`', f'`{a_type}` and `{b_type}`')

			elif word.op == 'MULT':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type != 'INT' or b_type != 'INT':
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')
				stack.append(('INT', word))

			elif word.op == 'DIV':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type != 'INT' or b_type != 'INT':
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')
				stack.append(('INT', word))

			elif word.op == 'DIVMOD':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type != 'INT' or b_type != 'INT':
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')
				
				stack.append(('INT', word))
				stack.append(('INT', word))
			
			elif word.op == 'ARGV':
				stack.append(('PTR', word))

			elif word.op == 'ARGC':
				stack.append(('INT', word))

			elif word.op == 'DUP':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				
				stack.append((a_type, a_loc))
				stack.append((a_type, word))

			elif word.op == 'SWAP':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				stack.append((a_type, a_loc))
				stack.append((b_type, b_loc))

			elif word.op == '2DUP':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				stack.append((b_type, b_loc))
				stack.append((a_type, a_loc))
				stack.append((b_type, word))
				stack.append((a_type, word))

			elif word.op == 'BINARY_OR':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type == 'INT' and b_type == 'INT':
					stack.append(('INT', word))
				else:
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')

			elif word.op == 'BINARY_AND':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type == 'INT' and b_type == 'INT':
					stack.append(('INT', word))
				else:
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')

			elif word.op == 'LOGICAL_OR':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				stack.append(('BOOL', word))

			
			elif word.op == 'LOGICAL_AND':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				stack.append(('BOOL', word))
				
			elif word.op == 'SHIFT_LEFT':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type != 'INT' or b_type != 'INT':
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')
				
				stack.append(('INT', word))

			elif word.op == 'SHIFT_RIGHT':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type != 'INT' or b_type != 'INT':
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')
				
				stack.append(('INT', word))

			elif word.op == 'LOAD':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()

				if a_type != 'PTR':
					invalid_arguments(word, '`PTR`', f'`{a_type}`')
				
				stack.append(('INT', word))

			elif word.op == 'STORE':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type not in ['INT', 'BOOL'] or b_type != 'PTR':
					invalid_arguments(word, '`INT` and `PTR`', f'`{a_type}` and `{b_type}`')

			elif word.op == 'DUMP':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()

				#if a_type != 'INT':
				#	invalid_arguments(word, '`INT`', f'`{a_type}`')

			elif word.op == 'DROP':
				if len(stack) < 1:
					not_enough_arguments(word)

				a = stack.pop()

			elif word.op == 'OVER':
				if len(stack) < 2:
					not_enough_arguments(word)

				a = stack.pop()
				b = stack.pop()

				stack.append(b)
				stack.append(a)
				stack.append(b)

			elif word.op == 'ROT':
				if len(stack) < 3:
					not_enough_arguments(word)

				a = stack.pop()
				b = stack.pop()
				c = stack.pop()

				stack.append(b)
				stack.append(a)
				stack.append(c)

			elif word.op == 'EQU':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				# if a_type != b_type:
				
				stack.append(('BOOL', word))

			elif word.op == 'NOT_EQU':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				# if a_type != b_type:
				
				stack.append(('BOOL', word))

			elif word.op == 'GREATER_THAN':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type != 'INT' or b_type != 'INT':
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')
				stack.append(('BOOL', word))

			elif word.op == 'LESS_THAN':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if a_type != 'INT' or b_type != 'INT':
					invalid_arguments(word, '`INT` and `INT`', f'`{a_type}` and `{b_type}`')
				stack.append(('BOOL', word))

			elif word.op == 'SYSCALL0':
				a_type, a_loc = stack.pop()

				if a_type != 'INT':
					invalid_arguments(word, '`INT`', f'`{a_type}`')

				stack.append(('INT', word))
			
			elif word.op == 'SYSCALL1':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b = stack.pop()

				if a_type != 'INT':
					invalid_arguments(word, '`INT`', f'`{a_type}`')

				stack.append(('INT', word))

			elif word.op == 'SYSCALL2':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b = stack.pop()
				c = stack.pop()

				if a_type != 'INT':
					invalid_arguments(word, '`INT`', f'`{a_type}`')

				stack.append(('INT', word))
			
			elif word.op == 'SYSCALL3':
				if len(stack) < 4:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b = stack.pop()
				c = stack.pop()
				d = stack.pop()

				if a_type != 'INT':
					invalid_arguments(word, '`INT`', f'`{a_type}`')

				stack.append(('INT', word))

			elif word.op == 'SYSCALL4':
				if len(stack) < 5:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b = stack.pop()
				c = stack.pop()
				d = stack.pop()
				e = stack.pop()

				if a_type != 'INT':
					invalid_arguments(word, '`INT`', f'`{a_type}`')

				stack.append(('INT', word))
			
			elif word.op == 'SYSCALL6':
				if len(stack) < 7:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b = stack.pop()
				c = stack.pop()
				d = stack.pop()
				e = stack.pop()
				f = stack.pop()
				g = stack.pop()
				
				if a_type != 'INT':
					invalid_arguments(word, '`INT`', f'`{a_type}`')

				stack.append(('INT', word))
				
			elif word.op == 'MEM':
				stack.append(('PTR', word))

			elif word.op == 'CAST_INT':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				stack.append(('INT', word))
				continue

			elif word.op == 'CAST_PTR':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()

				if a_type == 'BOOL':
					invalid_arguments(word, '`INT` or `PTR`', 'BOOL')
				
				stack.append(('PTR', word))
				continue

			elif word.op == 'CAST_BOOL':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				
				if a_type == 'PTR':
					invalid_arguments(word, '`INT` or `BOOL`', 'PTR')

				stack.append(('BOOL', word))
				continue

			elif word.op == 'LOAD64':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()

				if a_type != 'PTR':
					invalid_arguments(word, '`PTR`', f'`{a_type}`')

				stack.append(('INT', word))
			
			elif word.op == 'STORE64':
				if len(stack) < 2:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()
				b_type, b_loc = stack.pop()

				if b_type != 'PTR':
					invalid_arguments(word, '`?` and `PTR`', f'`{a_type}` and `{b_type}`')
				
			
			else:
				program_error(word, f"unknown word operation {word.op}")
				
		elif word.type == 'KEYWORD':
			if word.op == 'IF':
				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()

				if a_type != 'BOOL':
					invalid_arguments(word, '`BOOL`', f'`{a_type}`')

				block_stack.append((stack.copy(), word))

			elif word.op == 'ELIF':
				if len(block_stack) < 1:
					program_error(word, 'elif keyword is missing previous else block!')

				if len(stack) < 1:
					not_enough_arguments(word)

				a_type, a_loc = stack.pop()

				if a_type != 'BOOL':
					invalid_arguments(word, '`BOOL`', f'`{a_type}`')
				
				expected_stack, block_type, backup_stack = block_stack.pop()
				expected_types = list(map(lambda x: x[0], expected_stack))
				actual_types = list(map(lambda x: x[0], stack))
				
				if block_type.op != 'ELSE':
					program_error(word, 'elif keyword is missing previous else block!')
				
				if expected_types != actual_types:
					program_error_(block_type, 'else to elif block is not allowed to alter types on the stack')
					expected_vs_actual(word, expected_stack, stack)

				block_stack.append((stack_snapshot.copy(), word, backup_stack))
				#block_stack.append((actual_stack.copy(), word))
			
			elif word.op == 'ELSE':
				if len(block_stack) < 1:
					program_error(word, 'else keyword is missing previous if block!')

				prev = block_stack.pop()
				if len(prev) == 2:
					stack_snapshot, block_type = prev
				else:
					stack_snapshot, block_type, prev_stack = prev
				
				if block_type.op == 'ELIF':
					expected_types = list(map(lambda x: x[0], prev_stack))
					actual_types = list(map(lambda x: x[0], stack))
					#print("x:", expected_types, "a:", actual_types)
					if expected_types != actual_types:
						program_error_(block_type, 'this block\'s stack is not the same as the previous elif block stack')
						expected_vs_actual(word, prev_stack, stack)
					#block_stack.append((stack_snapshot.copy(), word))
					#stack = stack_snapshot

				#elif block_type.op == 'IF':
				#	#print("Stack: ", stack)
				#	block_stack.append((stack.copy(), word))
				#	stack = stack_snapshot
				block_stack.append((stack_snapshot.copy(), word, stack.copy()))
				stack = stack_snapshot

				#else:
				#	program_error(word, 'else keyword is missing previous if block!')

			elif word.op == 'WHILE':
				block_stack.append((stack.copy(), word))

			elif word.op == 'DO':
				if len(block_stack) < 1:
					program_error(word, 'do keyword is missing previous while block!')

				expected_stack, block_type = block_stack.pop()

				if block_type.op != 'WHILE':
					program_error(word, 'do keyword is missing previous while block!')

				if len(stack) < 1:
					not_enough_arguments(word)
					
				a_type, a_loc = stack.pop()

				if a_type != 'BOOL':
					invalid_arguments(word, '`BOOL`', f'`{a_type}`')

				expected_types = list(map(lambda x: x[0], expected_stack))
				actual_types = list(map(lambda x: x[0], stack))

				if expected_types != actual_types:
					program_error_(word, 'do block is not allowed to alter the types on the stack')
					expected_vs_actual(word, expected_stack, stack)
					#program_note(word, f'expected types: {expected_types}')
					#program_note(word, f'actual types: {actual_types}')
					#exit(1)

				block_stack.append((stack.copy(), word))
				
			elif word.op == 'END':
				if len(block_stack) == 0:
					program_error(word, 'end has no block')
				block = block_stack.pop()
				if len(block) == 2:
					expected_stack, block_type = block
				else:
					expected_stack, block_type, prev_stack = block
				
				expected_types = list(map(lambda x: x[0], expected_stack))
				actual_types = list(map(lambda x: x[0], stack))
				
				if block_type.op == 'IF':
					if expected_types != actual_types:
						program_error_(block_type, 'else-less if block is not allowed to alter types on the stack')
						expected_vs_actual(word, expected_stack, stack)
						#program_note(word, f'expected types: {expected_types}')
						#program_note(word, f'actual types: {actual_types}')
						#exit(1)

				elif block_type.op == 'ELSE':
					expected_types = list(map(lambda x: x[0], prev_stack))
					if expected_types != actual_types:
						program_error_(block_type, 'both if, else and elif blocks must produce the same types on the stack')
						expected_vs_actual(word, expected_stack, stack)
						#program_note(word, f'expected types: {expected_types}')
						#program_note(word, f'actual types: {actual_types}')
						#exit(1)

				elif block_type.op == 'ELIF':
					expected_types = list(map(lambda x: x[0], prev_stack))
					if expected_types != actual_types:
						program_error_(block_type, 'both if and else blocks must produce the same types on the stack')
						expected_vs_actual(word, expected_stack, stack)
				
				elif block_type.op == 'DO':
					if expected_types != actual_types:
						program_error_(block_type, 'while block is not allowed to alter the types on the stack')
						expected_vs_actual(word, expected_stack, stack)
						#program_note(word, f'expected types: {expected_types}')
						#program_note(word, f'actual types: {actual_types}')
						#exit(1)

				else:
					program_error_(word, 'invalid previous block type')
					program_note(block_type, 'located here')
					exit(1)

			elif word.op == 'MACRO':
				program_error(word, f"there shouldn't be a macro keyword here. It's probably a bug in the preprocessing")

		elif word.type == 'MACRO':
			program_error(word, f"there shouldn't be a macro here! It's probably a bug in the preprocessing")

		elif word.type == 'PROC_CALL':
			proc = procs[word.name]
			if len(stack) < len(proc['in']):
				stack_types = list(map(lambda a:a[0], stack))
				in_types = list(map(lambda a:a[0], proc['in']))
				program_error_(word, f"not enough arguments to call procedure `{word.name}`. Expected top of stack to be {in_types} but found {stack_types}")
				program_note(proc['word'], "procedure definition")
				exit(1)
			
			for i in proc['in']:
				stack.pop()
				
			for typ, w in proc['out']:
				stack.append((typ, word))

			#if word.name == 'PRINT_STACK':
			#	print("stack:", stack)
				
			#program_error(word, f"there shouldn't be a macro call here! It's probably a bug in the preprocessing")
						
		else:
			program_error(word, f'unknown word type `{word.type}`')
			
	if len(stack) != 0:
		if not checkingProc:
			program_error_(word, "unhandled data on the stack")
			program_note(word, "Stack at end of code:")
			for typ, word in stack:
				program_note(word, typ)
			exit(1)

	if len(block_stack) != 0:
		program_error_(word, "unhandled data on the block_stack")
		program_note(word, "Block_stack at end of code:")
		for s, word in block_stack:
			program_note(word, "...")
		exit(1)

	return stack

def typecheck_procs(procs):
	for name in procs:
		proc = procs[name]
		stack = proc['in'].copy()
		stack = typecheck_words(proc['body'], stack, procs, checkingProc=True)
		#print(name, stack, proc['in'], proc['out'])
		stack_types = list(map(lambda a:a[0], stack))
		out_types = list(map(lambda a:a[0], proc['out']))
		if stack_types != out_types:
			if len(stack_types) == 0:
				program_error(proc['word'], f"expected end of procedure to be {out_types}, but found nothing")
			elif len(out_types) == 0:
				program_error_(proc['word'], f"expected end of procedure to be nothing")
				print("Stack at end of code:")
				for typ, word in stack:
					program_note(word, typ)
				exit(1)
			else:
				program_error_(proc['word'], f"expected end of procedure to be {out_types}")
				print("Stack at end of code:")
				for typ, word in stack:
					program_note(word, typ)
					exit(1)
			
def typecheck_program(words, procs):
	#if procs != {}:
	#	compiler_error("ERROR: Procedures are currently not supported in typechecking. Disable typechecking at your on risk with the `--unsafe` flag")

	typecheck_procs(procs)
	
	stack: List[Tuple[String, Word]] = []
	words = typecheck_words(words, stack, procs)

def parse_procs(words):
	words_return = []
	#words_typecheck = []
	procs = {}
	while True:
		try:
			word = next(words)
		except StopIteration:
			break
		if word.type == 'KEYWORD' and word.op == 'PROC':
			try:
				name = next(words)
			except StopIteration:
				program_error(word, "expected procedure name but found none")
			if name.type != 'MACRO_CALL':
				program_error(name, "procedure name is wrong type")
			if name.name in procs.keys():
				program_error_(word, f"redefinition of already existing procedure `{name.name}`")
				program_note(procs[name.name]['word'], f"the first definition is located here")
				exit(1)

			args_in = []
			args_out = []
			dirOut = False
			while True:
				try:
					arg = next(words)
				except StopIteration:
					program_error(word, "expected `in` and `end` but found nothing")
				if arg.type == 'KEYWORD':
					if arg.op in ['PROC_INT', 'PROC_PTR', 'PROC_BOOL']:
						op = arg.op.replace('PROC_','')
						if dirOut:
							args_out.append((op, word))
						else:
							args_in.append((op, word))
					elif arg.op == 'PROC_BAR':
						if dirOut:
							program_error(arg, 'multiple seperation bars in proc header')
						dirOut = True
					elif arg.op == 'PROC_IN':
						break
					else:
						program_error(arg, f"`{arg.op}` is not supported inside procedure headers")
				else:
					program_error(arg, f"`{arg.type}` is not supported inside procedure headers")
					
			proc_words = []
			depth = 1
			while True:
				try:
					w = next(words)
				except StopIteration:
					program_error(word, "procedure has no end")
				
				if w.type == 'KEYWORD' and w.op == 'IF' or w.type == 'KEYWORD' and w.op == 'WHILE':
			   		depth += 1
					
				if w.type == 'KEYWORD' and w.op == 'END':
					depth -= 1

				if w.type == 'KEYWORD' and w.op == 'PROC':
					program_error(w, "local procedures are not supported")
					#assert False, "local procedures not supported yet"
				if depth == 0:
					break

				if w.type == 'MACRO_CALL':
					if w.name not in procs.keys() and w.name != name.name:
						program_error(w, f"procedure `{w.name}` does not exist")
					procs[w.name]['used'] = True
					proc_words.append(ProcCall(w, procs))
				else:
					proc_words.append(w)
				#words_typecheck.append(w)
			procs[name.name] = {'body': proc_words, 'word': word, 'in': args_in, 'out': args_out, 'index': len(procs), 'used': False}
		elif word.type == 'MACRO_CALL':
			if word.name not in procs.keys():
				matches = did_you_mean(word.name, procs.keys())
				if len(matches) >= 1:
					program_error_(word, f"procedure `{word.name}` doesn't exist")
					for c, match in matches:
						proc_word = procs[match]['word']
						program_note(proc_word, f"did you mean `{match}`?")
					exit(1)
				else:
					program_error(word, f"procedure `{word.name}` doesn't exist")
			procs[word.name]['used'] = True
			words_return.append(ProcCall(word, procs))
		else:
			words_return.append(word)
			#words_typecheck.append(word)
	#return iter(words_return), iter(words_typecheck), procs
	return words_return, procs
	
def generate_words(words, dataLabels):
	# [{'counter': 5, 'loop': False}, {'counter': 1, 'loop': True}]
	# depth: 2
	depthCounters = []
	labelDepth = 0
	memReserved = 0

	def updateLabels():
		if len(depthCounters) == 0:
			depthCounters.append(Depth(0))

		x = depthCounters[-1].depth
		#print("Last depth is", depthCounters[-1].depth)
		while len(depthCounters) <= labelDepth:
			x += 1
			depthCounters.append(Depth(x))
	
	code = ""
	
	for word in words:
		if word.type == 'CONST':
			if word.value_type == 'INT':
				code +=  '\n    ;; -- CONST INT -- ;;\n'
				code += f'    push    {word.value}\n'
				#code += f'    mov     rax, {word.value}\n'
				#code +=  '    push    rax\n'

			elif word.value_type == 'STR':
				label = 'str_' + str(len(dataLabels))
				dataLabels.append({'label': label, 'data': word.value, 'cstr': False})
				size = len(word.value)
				code +=  '\n    ;; -- CONST STR -- ;;\n'
				code += f'    push    {size}\n'
				code += f'    push    {label}\n'

			elif word.value_type == 'CSTR':
				label = 'cstr_' + str(len(dataLabels))
				dataLabels.append({'label': label, 'data': word.value, 'cstr': True})
				code +=  '\n    ;; -- CONST CSTR -- ;;\n'
				code += f'    push    {label}\n'
				
			elif word.value_type == 'CHAR':
				code +=  '\n    ;; -- CONST CHAR -- ;;\n'
				code += f'    push    {word.value}\n'

			elif word.value_type == 'MEMORY_OFFSET':
				size = word.value[0]
				offset = word.value[1]
				code +=  '\n    ;; -- CONST MEMORY PTR -- ;;\n'
				code += f'    mov     rax, mem\n'
				code += f'    add     rax, {offset}\n'
				code +=  '    push    rax\n'
				memReserved = max(memReserved, size+offset)
				# mems[name] = size
				
			else:
				program_error(word, f"unknown const type '{word.value_type}'")
				
		elif word.type == 'WORD':
			#print(f"Generating WORD operation {word.op}")
			if word.op == 'ADD':
				code += '\n    ;; -- ADD -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rax\n'
				code += '    add     rax, rcx\n'
				code += '    push    rax\n'
				
			elif word.op == 'SUB':
				code += '\n    ;; -- SUB -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    sub     rcx, rax\n'
				code += '    push    rcx\n'

			elif word.op == 'MULT':
				code += '\n    ;; -- MULT -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    mul     rcx\n'
				code += '    push    rax\n'

			elif word.op == 'DIV':
				code += '\n    ;; -- DIV -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rax\n'
				code += '    cdq\n'
				code += '    idiv    rcx\n'
				code += '    push    rax\n'

			elif word.op == 'DIVMOD':
				code += '\n    ;; -- DIV -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rax\n'
				code += '    cdq\n'
				code += '    idiv    rcx\n'
				code += '    push    rax\n'
				code += '    push    rdx\n'

			elif word.op == 'ARGV':
				code += '\n    ;; -- ARGV -- ;;\n'
				code += '    mov     rax, [argv]\n'
				code += '    push    rax\n'

			elif word.op == 'ARGC':
				code += '\n    ;; -- ARGC -- ;;\n'
				code += '    mov     rax, [argc]\n'
				code += '    push    rax\n'
			
			elif word.op == 'BINARY_OR':
				code += '\n    ;; -- BINARY_OR -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rbx\n'
				code += '    or      rbx, rax\n'
				code += '    push    rbx\n'
				
			elif word.op == 'BINARY_AND':
				code += '\n    ;; -- BINARY_AND -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rbx\n'
				code += '    and     rbx, rax\n'
				code += '    push    rbx\n'

			elif word.op == 'LOGICAL_OR':
				code += '\n    ;; -- LOGICAL_OR -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rbx\n'
				code += '    xor     rcx, rcx\n'
				code += '    mov     rdx, 1\n'
				code += '    cmp     rax, 0\n'
				code += '    cmovne  rcx, rdx\n'
				code += '    cmp     rbx, 0\n'
				code += '    cmovne  rcx, rdx\n'
				code += '    push    rcx\n'

			elif word.op == 'LOGICAL_AND':
				code += '\n    ;; -- LOGICAL_AND -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rbx\n'
				code += '    xor     rcx, rcx\n'
				code += '    mov     rdx, 1\n'
				code += '    test    rax, rax\n'
				code += '    cmovz   rdx, rcx\n'
				code += '    test    rbx, rbx\n'
				code += '    cmovz   rdx, rcx\n'
				code += '    push    rdx\n'
								
			elif word.op == 'SHIFT_LEFT':
				code += '\n    ;; -- SHIFT_LEFT -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rbx\n'
				code += '    shl     rbx, cl\n'
				code += '    push    rbx\n'
				
			elif word.op == 'SHIFT_RIGHT':
				code += '\n    ;; -- SHIFT_RIGHT -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rbx\n'
				code += '    shr     rbx, cl\n'
				code += '    push    rbx\n'
				
			elif word.op == 'DUMP':
				code += '\n    ;; -- DUMP -- ;;\n'
				code += '    pop     rdi\n'
				code += '    call    dump\n'
				
			elif word.op == 'EQU':
				code += '\n    ;; -- EQU -- ;;\n'
				code += '    xor     rdx, rdx\n'
				code += '    mov     rbx, 1\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    cmp     rax, rcx\n'
				code += '    cmove   rdx, rbx\n'
				code += '    push    rdx\n'

			elif word.op == 'NOT_EQU':
				code += '\n    ;; NOT_EQU -- ;;\n'
				code += '    xor     rdx, rdx\n'
				code += '    mov     rbx, 1\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    cmp     rax, rcx\n'
				code += '    cmovne  rdx, rbx\n'
				code += '    push    rdx\n'
				
			elif word.op == 'DUP':
				code += '\n    ;; -- DUP -- ;;\n'
				code += '    pop     rax\n'
				code += '    push    rax\n'
				code += '    push    rax\n'
				
			elif word.op == '2DUP':
				code += '\n    ;; -- 2DUP -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    push    rcx\n'
				code += '    push    rax\n'
				code += '    push    rcx\n'
				code += '    push    rax\n'
				
			elif word.op == 'SWAP':
				code += '\n    ;; -- SWAP -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    push    rax\n'
				code += '    push    rcx\n'
				
			elif word.op == 'DROP':
				code += '\n    ;; -- DROP -- ;;\n'
				code += '    pop     rax\n'
				
			elif word.op == 'OVER':
				code += '\n    ;; -- OVER -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    push    rcx\n'
				code += '    push    rax\n'
				code += '    push    rcx\n'

			elif word.op == 'ROT':
				code += '\n    ;; -- ROT -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    pop     rbx\n'
				code += '    push    rcx\n'
				code += '    push    rax\n'
				code += '    push    rbx\n'
				
			elif word.op == 'GREATER_THAN':
				code += '\n    ;; -- GREATER_THAN -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    xor     rdx, rdx\n'
				code += '    mov     rbx, 1\n'
				code += '    cmp     rcx, rax\n'
				code += '    cmovg   rdx, rbx\n'
				code += '    push    rdx\n'
				
			elif word.op == 'LESS_THAN':
				code += '\n    ;; -- LESS_THAN -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    xor     rdx, rdx\n'
				code += '    mov     rbx, 1\n'
				code += '    cmp     rcx, rax\n'
				code += '    cmovl   rdx, rbx\n'
				code += '    push    rdx\n'
				
			elif word.op == 'MEM':
				code += '\n    ;; -- MEM -- ;;\n'
				code += '    push    mem\n'
				
			elif word.op == 'LOAD':
				code += '\n    ;; -- LOAD -- ;;\n'
				code += '    pop     rax\n'
				code += '    xor     rbx, rbx\n'
				code += '    mov     bl, [rax]\n'
				code += '    push    rbx\n'
				
			elif word.op == 'STORE':
				code += '\n    ;; -- STORE -- ;;\n'
				code += '    pop     rbx\n'  # 97
				code += '    pop     rax\n'  # mem
				code += '    mov     [rax], bl\n' # Move lower 8 bits into mem

			elif word.op == 'LOAD64':
				code += '\n    ;; -- LOAD64 -- ;;\n'
				code += '    pop     rax\n'
				code += '    xor     rbx, rbx\n'
				code += '    mov     rbx, [rax]\n'
				code += '    push    rbx\n'

			elif word.op == 'STORE64':
				code += '\n    ;; -- STORE64 -- ;;\n'
				code += '    pop     rbx\n'
				code += '    pop     rax\n'
				code += '    mov     [rax], rbx\n'

			elif word.op == 'SYSCALL0':
				code += '\n    ;; -- SYSCALL0 -- ;;\n'
				code += '    pop     rax\n'
				code += '    syscall\n'
				code += '    push    rax\n'
			
			elif word.op == 'SYSCALL1':
				code += '\n    ;; -- SYSCALL1 -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rdi\n'
				code += '    syscall\n'
				code += '    push    rax\n'

			elif word.op == 'SYSCALL2':
				code += '\n    ;; -- SYSCALL1 -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rdi\n'
				code += '    pop     rsi\n'
				code += '    syscall\n'
				code += '    push    rax\n'
				
			elif word.op == 'SYSCALL3':
				code += '\n    ;; -- SYSCALL3 -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rdi\n'
				code += '    pop     rsi\n'
				code += '    pop     rdx\n'
				code += '    syscall\n'
				code += '    push    rax\n'

			elif word.op == 'SYSCALL4':
				code += '\n    ;; -- SYSCALL3 -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rdi\n'
				code += '    pop     rsi\n'
				code += '    pop     rdx\n'
				code += '    pop     r10\n'
				code += '    syscall\n'
				code += '    push    rax\n'
		
			elif word.op == 'SYSCALL6':
				code += '\n    ;; -- SYSCALL6 -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rdi\n'
				code += '    pop     rsi\n'
				code += '    pop     rdx\n'
				code += '    pop     r10\n'
				code += '    pop     r8\n'
				code += '    pop     r9\n'
				code += '    syscall\n'
				code += '    push    rax\n'
			
			#elif word.op == 'CAST_INT':
			#	program_error(word, f"the cast shouldn't be here! It's probably a bug in the typechecker")
			#	
			#elif word.op == 'CAST_PTR':
			#	program_error(word, f"the cast shouldn't be here! It's probably a bug in the typechecker")
			#	
			#elif word.op == 'CAST_BOOL':
			#	program_error(word, f"the cast shouldn't be here! It's probably a bug in the typechecker")
			#	
			#else:
			#	program_error(word, f"unreckognized word '{word.op}'")
				
		elif word.type == 'KEYWORD':
			#print(f"Generating KEYWORD operation {word.op}")
			if word.op == 'WHILE':
				updateLabels()
				depthCounters[labelDepth].loop = True
				while_label = depthCounters[labelDepth].nextLabel()
				depthCounters[labelDepth].counter += 1
				labelDepth += 2
				updateLabels()
				code += '\n;; -- WHILE -- ;;\n'
				code += f'{while_label}:\n'
				
			elif word.op == 'DO':
				end_label = depthCounters[labelDepth-2].nextLabel()
				code += '\n;; -- DO -- ;;\n'
				code +=  '    pop     rax\n'
				code +=  '    test    rax, rax\n'
				code += f'    jz      {end_label}\n'
				
			elif word.op == 'IF':
				labelDepth += 1
				updateLabels()
				label = depthCounters[labelDepth].nextLabel()
				depthCounters[labelDepth].counter -= 1
				labelDepth += 1
				updateLabels()
				code +=  '\n    ;; -- IF -- ;;\n'
				code +=  '    pop     rax\n'
				code +=  '    test    rax, rax\n'
				code += f'    jz      {label}\n'

			elif word.op == 'ELIF':
				label = depthCounters[labelDepth-1].nextLabel()
				depthCounters[labelDepth-1].counter -= 1
				code +=  '\n;; -- ELIF -- ;;\n'
				code +=  '    pop     rax\n'
				code +=  '    test    rax, rax\n'
				code += f'    jz      {label}\n'
			
			elif word.op == 'ELSE':
				else_label = depthCounters[labelDepth-1].nextLabel()
				end_label = depthCounters[labelDepth-2].label()
				code +=  '\n;; -- ELSE -- ;;\n'
				code += f'    jmp {end_label}\n'
				code += f'{else_label}:\n'
				
			elif word.op == 'END':
				if_label = depthCounters[labelDepth-1].nextLabel()
				depthCounters[labelDepth-1].counter += 1
				labelDepth -= 2
				label = depthCounters[labelDepth].label()
				code += '\n;; -- END -- ;;\n'
				if depthCounters[labelDepth].loop:
					depthCounters[labelDepth].loop = False
					depthCounters[labelDepth].counter -= 2
					while_label = depthCounters[labelDepth].label()
					depthCounters[labelDepth].counter += 2
					code += f'    jmp     {while_label}\n'
				depthCounters[labelDepth].counter += 1
				code += f'{label}: ; end_label\n'
				code += f'{if_label}:\n'

			elif word.op == 'INCLUDE':
				program_error(word, f"there shouldn't be an `include` here! It's probably a bug in the preprocessing")

			else:
				program_error(word, f"unreckognized keyword operation '{word.op}'")

		elif word.type == 'MACRO':
			program_error(word, f"there shouldn't be a macro here! It's probably a bug in the preprocessing")

		elif word.type == 'PROC_CALL':
			# Checking if the procedure exists is done
			# in parse_procs
			code += f'\n;; -- proc_{word.name} -- ;;\n'
			code += f'    call proc_{word.index}\n'
			#program_error(word, f"there shouldn't be a macro call here! It's probably a bug in the preprocessing")
			
		else:
			program_error(word, f"unreckognized word type: '{word.type}'")

	return code, memReserved


def generate_program(words, procs, args):
	code =  'section .text\n'
	code += 'global _start\n'

	code += f"""\
BITS 64
dump:
    mov     r9, -3689348814741910323
    sub     rsp, 40
    mov     BYTE [rsp+31], 10
    lea     rcx, [rsp+30]
.L1:
    mov     rax, rdi
    lea     r8, [rsp+32]
    mul     r9
    mov     rax, rdi
    sub     r8, rcx
    shr     rdx, 3
    lea     rsi, [rdx+rdx*4]
    add     rsi, rsi
    sub     rax, rsi
    add     eax, 48
    mov     BYTE [rcx], al
    mov     rax, rdi
    mov     rdi, rdx
    mov     rdx, rcx
    sub     rcx, 1
    cmp     rax, 9
    ja      .L1
    lea     rax, [rsp+32]
    mov     edi, 1
    sub     rdx, rax
    xor     eax, eax
    lea     rsi, [rsp+32+rdx]
    mov     rdx, r8
    mov     rax, 1
    syscall
    add     rsp, 40
    ret
"""
	code += '_start:\n'
	code += '    ; Set up return stack\n'
	code += '    mov     r15, ret_stack\n'
	code += '    ; Set up argc and argv\n'
	code += '    mov     rax, [rsp]\n'
	code += '    mov     [argc], rax\n'
	code += '    lea     rax, [rsp+8]\n'
	code += '    mov     [argv], rax\n'

	dataLabels = []
	c, memReserved = generate_words(words, dataLabels)
	code += c
	
	#code += '    ret\n'

	code += '    xor     rdi, rdi\n'
	code += '    mov     rax, 60\n'
	code += '    syscall\n'
	
	for name in procs:
		proc = procs[name]

		# Remove unused procedure code
		if not proc['used'] and not args.disOpt:
			continue
		
		body = proc['body']
		index = proc['index']
		c, mem = generate_words(body, dataLabels)
		code += f'\nproc_{index}:\n'
		code += '    pop     r14\n'
		code += '    mov     [r15], r14\n'
		code += '    add     r15, 8\n'
		code += c
		code += '\n;; -- Return stack magic -- ;;\n'
		code += '    sub     r15, 8\n'
		code += '    mov     r14, [r15]\n'
		code += '    jmp     r14\n'
		memReserved += mem
	
	code += '\nsegment .data\n'
	
	for data in dataLabels:
		data_bytes = ','.join(map(hex, bytes(data['data'], 'utf-8')))	
		code += f'{data["label"]}:\n'
		if data['cstr']:
			code += f'    db      {data_bytes},0\n'
		else:
			code += f'    db      {data_bytes}\n'

	code +=  'segment .bss\n'
	code +=  'argc:\n'
	code +=  '    resb    8\n'
	code +=  'argv:\n'
	code +=  '    resb    8\n'
	code +=  'mem:\n'
	code += f'    resb    {memReserved}\n'
	code +=  'ret_stack:\n'
	code +=  '    resb    4096\n'
		
	return code
		
def main():
	arguments = parse_args()

	# Help if --help or no arguments
	if arguments.help or arguments.none:
		print(help_message)
		exit()

	# No input file
	if not arguments.infn:
		compiler_error('ERROR: no input files supplied')

	# Infile doesn't exist
	if not os.path.isfile(arguments.infn):
		compiler_error(f"ERROR: {arguments.infn}: No such file or directory")

	# Lexing
	tokens = lex_file(arguments.infn)

	# Parsing
	words = parse(tokens)
	
	# Preprocess (includes and macro expansion)
	words = preprocess(words, arguments)

	# Procedures
	words, procs = parse_procs(words)
	
	# Typechecking
	if not arguments.unsafe:
		start_typecheck = time.time()
		typecheck_program(words, procs)
		end_typecheck = time.time()
		print(f'[INFO] Typechecking took {end_typecheck-start_typecheck:0.5f}s')
		
	start_compile = time.time()
	
	# Compiling
	code = generate_program(words, procs, arguments)

	end_compile = time.time()

	print(f'[INFO] Compiling took {end_compile-start_compile:0.5f}s')
	
	tmp_asm = '.tmp_bip_bop.s'
	tmp_o = '.tmp_bip_bop.o'
	
	# Write the generated assembly code to the file
	with open(tmp_asm, 'w') as asmfile:
		asmfile.write(code)
		asmfile.close()

	if arguments.asm:
		os.rename(tmp_asm, arguments.outfn)
		return

	nasm_args = ['nasm', '-f', 'elf64', '-o', tmp_o, tmp_asm]
	ld_args = ['ld', '-o', arguments.outfn, tmp_o]
	
	start = time.time()

	print("[CMD]", ' '.join(nasm_args))
	nasm = subprocess.Popen(nasm_args)
	nasm.communicate()

	if nasm.returncode != 0:
		exit(1)

	print("[CMD]", ' '.join(ld_args))
	ld = subprocess.Popen(ld_args)
	ld.communicate()

	if ld.returncode != 0:
		exit(1)
	
	end = time.time()

	print(f'[INFO] Assembling took {end-start:0.5f}s')

	os.remove(tmp_asm)
	os.remove(tmp_o)

	if arguments.run:
		fn_to_run = './' + arguments.outfn
		print(f"Running '{fn_to_run}'\n")
		# Segmentation fault show show?
		process = subprocess.Popen([fn_to_run])
		process.communicate()

		if process.returncode == 0:
			print("\nProcess exited normally with exit code 0")
			os.remove(arguments.outfn)
		else:
			print(f"\nProcess exited abnormally with exit code {process.returncode}")
		
if __name__ == "__main__":
	main()
	exit(0)
