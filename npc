#!/usr/bin/python3

# rework branch

import sys, os, re
import itertools

# source_re = r"int main\s*\(\s*\)\s*{\s*return\s+(?P<ret>[0-9]+)\s*;\s*}"

# hex: 0[xX][0-9a-fA-F]+

# Bakkes-Naur
# <program> ::= <function>
# <function> ::= "fun" <id> "" <statement> "}"
# <statement> ::= "return" <exp> ";"
# <exp> ::= <logical-and-exp> { ("||" | "|") <logical-and-exp> }
# <logical-and-exp> ::= <equality-exp> { ("&&" | "&" | "^") <equality-exp> }
# <equality-exp> ::= <relational-exp> { ("!=" | "==" ) <relational-exp> }
# <relational-exp> ::= <additive-exp> { ("<" | ">" | "<=" | ">=") <additive-exp> }
# <additive-exp> ::= <term> { ("+" | "-") <term> }
# <term> ::= <factor> { ("*" | "/" | "%") <factor> }
# <factor> ::= "(" <exp> ")" | <unary-op> <factor> | <int>
# <unary-op> ::= "!" | "~" | "-"

# Keywords regex
lexing_keywords = r"([a-zA-Z]+|\d|\+)"

# For function names
function_name_regex = r"[a-zA-Z]\w*"

# Help message
help_message ="""\
Usage: npc file [options]

Options:
  -o <file>    Place the output into file.
  -p           Pretty-print the AST of the program.
  -S           Do not assemble, output is assembly code.
  -h           Display this information and exit."""

base_asm = """\
.text
.globl main
main:
"""
#    movl    ${}, %eax
#    ret


class Arguments:
	def __init__(self):
		self.infn = None
		self.outfn = None
		self.asmfn = None
		self.pretty = None
		self.help = None
		self.none = None
		self.asm = None

class Token:
	def __init__(self, type):
		self.type = type

class Function(Token):
	def __init__(self, id, words): # params
		super().__init__("FUNCTION")
		self.id = id
		self.words = words

class Program(Token):
	def __init__(self, functions):
		super().__init__("PROGRAM")
		self.functions = functions

class Const(Token):
	def __init__(self, value_type, value):
		super().__init__("CONST")
		self.value_type = value_type
		self.value = value

class BinaryOperator(Token):
	def __init__(self, op):
		super().__init__("BINARY_OPERATOR")
		self.op = op

def fail():
	raise Exception("Error")


def lex(source_file):
	# Read and get matches from regex
	with open(source_file, 'r') as infile:
		source = infile.read().strip()
		matches = re.findall(lexing_keywords, source)

	# Filter out '' in the list, could probably be done easier in the regex
	matches = list(filter(lambda x: x != '', matches))

	print(matches)

	# Yield tokens (creates a generator)
	for match in matches:
		yield match.replace(' ', '') # No tokens should have spaces in them

def parseWord(tok):
	print(f'Parsing token: {tok}')
	
	if tok.isnumeric():
		return Const('INT', int(tok))
	elif tok == '+':
		return BinaryOperator('ADD')
	elif tok == '-':
		return BinaryOperator('SUBTRACT')
	elif tok == '*':
		return BinaryOperator('MULTIPLY')
	elif tok == '/':
		return BinaryOperator('DIVIDE')
	else:
		fail()

def parseFunction(tokens):
	tok = next(tokens)
	if tok != 'fun':
		fail()

	id = next(tokens)

	# Invalid function name
	#if not re.match(function_name_regex, id):
	#	fail()

	tok = next(tokens)
	if tok != 'in':
		fail()

	# Support for multiple statements
	# statement = None
	# while True:
	#   statement = ...
	#   if nextToken==None: EOF, fail()
	#   if nextToken=='}': break
	words = []

	while True:
		tok = next(tokens)
		if tok == 'end': break
		word = parseWord(tok)
		words.append(word)

	print(f"Words: {words}")
	function = Function(id, words)

	return function

def parse(tokens):
	function = parseFunction(tokens)
	program = Program([function])
	return program


def pretty_print(obj, n=0):
	space = '    '
	if obj.type == "PROGRAM":
		print("PROGRAM:")
		for func in obj.functions:
			pretty_print(func, n+1)

	elif obj.type == "FUNCTION":
		print(space*(n+0) + f"FUN {obj.id}:")
		print(space*(n+1) +  "params: ()") # None yet
		print(space*(n+1) +  "body:")
		pretty_print(obj.body, n+1)

	elif obj.type == "BODY":
		for statement in obj.statements:
			if statement.type == "RETURN":
				pretty_print(statement.exp, n+1)
			else:
				print(space*(n+2) + f"{statement.type} ???")

	elif obj.type == "UNOP":
		print(space*(n+0) + f"UNOP<{obj.op.operator}, {obj.value.type}>")
		pretty_print(obj.value, n+1)

	elif obj.type == "BINOP":
		print(space*(n+0) + f"BINOP<{obj.left.type}, {obj.op.operator}, {obj.right.type}>")
		pretty_print(obj.left, n+1)
		pretty_print(obj.op, n+1)
		pretty_print(obj.right, n+1)

	elif obj.type == "CONST":
		print(space*n + f"CONST<{obj.value_type}<{obj.value}>>")

def parse_args():
	argv = (x for x in sys.argv)
	arguments = Arguments() # Put default values here

	# No arguments so skip and save
	if len(sys.argv) == 1:
		arguments.none = True
		return arguments

	# Since the first one is npc, the second is the file name
	next(argv)

	first = next(argv)
	if first == '--help':
		arguments.help = True
		return arguments

	arguments.infn = first

	while True:
		try:
			arg = next(argv)
		except:
			break

		# print("Arg:", arg)

		if arg == '-p':
			arguments.pretty = True

		elif arg == '-S':
			arguments.asm = True

		elif arg == '-o':
			try:
				arg = next(argv)
			except:
				fail()

			arguments.outfn = arg

		# Unreckgnised argument
		else:
			fail()

	return arguments

labelCounter = 0

def generateLabel():
	global labelCounter
	labelCounter += 1
	return "L" + str(labelCounter)

def generateWord(word):
	print(f'Word type: {word.type}')
	
	code = ''
	if word.type == 'CONST':
		code += f'    mov     eax, {word.value}\n'
		code +=  '    push    eax\n'
	
	elif word.type == 'BINARY_OPERATOR':
		if word.op == 'ADD':
			code += '    pop     ebx\n'
			code += '    pop     eax\n'
			code += '    add     eax, ebx\n'
			code += '    mov     eax, 4\n'
			
	return code
			
def generateFunction(func):
	code =  f'section .text\n'
	code += f'global main\n'
	code += f'main:\n'
	for word in func.words:
		code += generateWord(word)
	code += '    ret\n'
	return code

def generateProgram(prog):
	code = ''
	for func in prog.functions:
		code += generateFunction(func)
	return code
		
def main():
	arguments = parse_args()

	# Help if --help or no arguments
	if arguments.help or arguments.none:
		print(help_message)
		exit()

	# No input file
	if not arguments.infn:
		fail()

	# Infile doesn't exist
	if not os.path.isfile(arguments.infn):
		fail()

	tokens = lex(arguments.infn)

	prog = parse(tokens)

	# Pretty printing
	if arguments.pretty:
		pretty_print(prog)

	code = generateProgram(prog)

	# Correct filenames to write to
	if arguments.asm and arguments.outfn:
		arguments.asmfn = arguments.outfn
	else:
		arguments.asmfn = os.path.splitext(arguments.infn)[0] + '.s'

	if (not arguments.asm) and (not arguments.outfn):
		arguments.outfn = 'a.out'

	# Write the generated assembly code to the file
	with open(arguments.asmfn, 'w') as asmfile:
		asmfile.write(code)

	# Assemble and delete temporary assembly file
	if not arguments.asm:
		os.system(f"gcc {arguments.asmfn} -m32 -g -o {arguments.outfn}")
		os.remove(arguments.asmfn)

if __name__ == "__main__":
	main()
