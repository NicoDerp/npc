#!/usr/bin/python3

# rework branch

import sys, os, re
import subprocess
import time

# Help message
help_message ="""\
Usage: npc <file> [options]

Options:
  -o <file>    Place the output into file
  -p           Pretty-print the AST of the program
  -S           Do not assemble, output is assembly code
  -r           Run the program after a succesful compilation
  --help       Display this information and exit"""


class Arguments:
	def __init__(self):
		self.infn = None
		self.outfn = 'a.out'
		self.pretty = None
		self.help = None
		self.none = None
		self.asm = None
		self.run = None
		self.include_path = './'
		
class Classified:
	def __init__(self, type):
		self.type = type

class Function(Classified):
	def __init__(self, id, words): # params
		super().__init__("FUNCTION")
		self.id = id
		self.words = words

class Program(Classified):
	def __init__(self, functions):
		super().__init__("PROGRAM")
		self.functions = functions

class Position():
	def __init__(self, tok):
		self.row = tok.row
		self.col = tok.col
		self.filepath = tok.filepath
		
class Const(Classified, Position):
	def __init__(self, value_type, value, tok):
		Classified.__init__(self, "CONST")
		Position.__init__(self, tok)
		self.value_type = value_type
		self.value = value

class Keyword(Classified, Position):
	def __init__(self, op, tok):
		Classified.__init__(self, "KEYWORD")
		Position.__init__(self, tok)
		self.op = op

class Word(Classified, Position):
	def __init__(self, op, tok):
		Classified.__init__(self, "WORD")
		Position.__init__(self, tok)
		self.op = op

class Token():
	def __init__(self, token, row, col, filepath):
		self.token = token
		self.row = row
		self.col = col
		self.filepath = filepath

class Depth():
	def __init__(self, depth):
		self.counter = 0
		self.depth = depth
		self.loop = False

	def label(self):
		return f".L{self.depth}.{self.counter}"

	def nextLabel(self):
		self.counter += 1
		return f".L{self.depth}.{self.counter}"
	
def syntaxError(word, err):
	word.row += 1 if word.row != 0 else 0  # Since emacs is dum dum
	print(f"{word.filepath}:{word.row}:{word.col}: {err}")
	exit(1)

def compilationError(err):
	print(err)
	exit(1)

def lexFile(source_file):
	# Read and get tokens (not including comments)
	with open(source_file, 'r') as infile:
		# Comments!
		lines = [line.split('//', 1)[0] for line in infile.readlines()]
		matches = [((token.start(), token.group()) for token in re.finditer(r"\"(.+?)\"|'(.+?)'|\S+", line)) for line in lines]
		
	for row, i in enumerate(matches):
		for col, tok in i:
			#print(f"Row: {row}, Col: {col}, Token: {tok}")
			yield Token(tok, row, col, source_file)

def parseString(tok):
	# Only one character so def no string
	if len(tok.token) == 1:
		syntaxError(tok, f"ERROR: unclosed string literal `{tok.token}`")

	quote = tok.token[0]
	# Not a quote (shouldn't occur)
	if not quote in '\'"':
		syntaxError(tok, f"ERROR: unclosed string literal `{tok.token}`")

	# Two different quotes
	if quote != tok.token[-1]:
		syntaxError(tok, f"ERROR: unclosed string literal `{tok.token}`")
	
	# Remove quotes
	s = tok.token[1:-1]

	# For escaped stuff, convert to bytes, then back again
	bytes_string = bytes(s, 'utf-8')
	s = bytes_string.decode('unicode_escape')

	# String
	if quote == '"':
		return Const('STRING', s, tok)
	
	# Character
	if len(s) != 1:
		syntaxError(tok, f"ERROR: only a single byte is allowed inside a character literal")

	return Const('CHARACTER', hex(ord(s)), tok)

def parseToken(tok):	
	if tok.token == '+':
		return Word('ADD', tok)

	elif tok.token == '-':
		return Word('SUB', tok)

	elif tok.token == 'bor':
		return Word('BINARY_OR', tok)

	elif tok.token == 'band':
		return Word('BINARY_AND', tok)

	elif tok.token == 'shl':
		return Word('SHIFT_LEFT', tok)

	elif tok.token == 'shr':
		return Word('SHIFT_RIGHT', tok)
	
	elif tok.token == 'dump':
		return Word('DUMP', tok)

	elif tok.token == '=':
		return Word('EQU', tok)

	elif tok.token == 'dup':
		return Word('DUP', tok)

	elif tok.token == '2dup':
		return Word('2DUP', tok)
	
	elif tok.token == 'swap':
		return Word('SWAP', tok)

	elif tok.token == 'drop':
		return Word('DROP', tok)

	elif tok.token == 'over':
		return Word('OVER', tok)
	
	elif tok.token == '>':
		return Word('GREATER_THAN', tok)

	elif tok.token == '<':
		return Word('LESS_THAN', tok)

	elif tok.token == 'mem':
		return Word('MEM', tok)

	elif tok.token == ',':
		return Word('LOAD', tok)

	elif tok.token == '.':
		return Word('STORE', tok)

	elif tok.token == 'syscall1':
		return Word('SYSCALL1', tok)
	
	elif tok.token == 'syscall3':
		return Word('SYSCALL3', tok)
	
	elif tok.token == 'fun':
		return Keyword('FUNCTION', tok)

	elif tok.token == 'in':
		return Keyword('IN', tok)
	
	elif tok.token == 'if':
		return Keyword('IF', tok)

	elif tok.token == 'else':
		return Keyword('ELSE', tok)

	elif tok.token == 'end':
		return Keyword('END', tok)
	
	elif tok.token == 'while':
		return Keyword('WHILE', tok)

	elif tok.token == 'do':
		return Keyword('DO', tok)

	elif tok.token == 'include':
		return Keyword('INCLUDE', tok)
	
	else:
		if '\'' in tok.token or '\"' in tok.token:
			return parseString(tok)
		try:
			return Const('INT', int(tok.token), tok)
		except ValueError as err:
			syntaxError(tok, "ERROR: " + err)
			
def parse(tokens):
	for tok in tokens:
		yield parseToken(tok)

def pretty_print(obj, n=0):
	space = '    '
	print('Wiiu')
	
def parse_args():
	argv = (x for x in sys.argv)
	arguments = Arguments() # Put default values here

	# No arguments so skip and save
	if len(sys.argv) == 1:
		arguments.none = True
		return arguments

	# Since the first one is npc, the second is the file name
	next(argv)

	first = next(argv)
	if first == '--help':
		arguments.help = True
		return arguments

	arguments.infn = first

	while True:
		try:
			arg = next(argv)
		except:
			break

		# print("Arg:", arg)

		if arg == '-p':
			arguments.pretty = True

		elif arg == '-S':
			arguments.asm = True

		elif arg == '-r':
			arguments.run = True
			
		elif arg == '-o':
			try:
				arg = next(argv)
			except:
				print("ERROR: failed to parse args, missing filename after '-o'")
				exit(1)

			arguments.outfn = arg

		elif arg == '-I':
			try:
				arg = next(argv)
			except:
				print("ERROR: failed to parse args, missing path after '-I'")
				exit(1)
			
			arguments.include_path = arg
			
		# Unreckgnised argument
		else:
			fail("unreckognized argument '{arg}'")

	return arguments

def preprocess(words, args, includes=0):
	while True:
		try:
			word = next(words)
		except StopIteration:
			break
		
		if word.type == 'KEYWORD' and word.op == 'INCLUDE':
			inc = next(words)
			if inc.type != 'CONST' or inc.value_type != 'STRING':
				syntaxError(inc, f'ERROR: expected string to include got \'{inc.type}\'')
			fileName = os.path.join(args.include_path, inc.value)
			if not os.path.exists(fileName):
				syntaxError(inc, f"ERROR: couldn't include file `{fileName}` because it does not exist! Double check the name and include paths.")
			includes += 1
			# Max includes
			if includes >= 5:
				print(f"ERROR: max includes reached: `{includes}`")
				exit(1)
			for word in preprocess((parseToken(w) for w in lexFile(fileName)), args, includes):
				yield word
		else:
			yield word

def generateProgram(words):
	code =  'section .text\n'
	code += 'global _start\n'

	code += f"""\
BITS 64
dump:
    mov     r9, -3689348814741910323
    sub     rsp, 40
    mov     BYTE [rsp+31], 10
    lea     rcx, [rsp+30]
.L1:
    mov     rax, rdi
    lea     r8, [rsp+32]
    mul     r9
    mov     rax, rdi
    sub     r8, rcx
    shr     rdx, 3
    lea     rsi, [rdx+rdx*4]
    add     rsi, rsi
    sub     rax, rsi
    add     eax, 48
    mov     BYTE [rcx], al
    mov     rax, rdi
    mov     rdi, rdx
    mov     rdx, rcx
    sub     rcx, 1
    cmp     rax, 9
    ja      .L1
    lea     rax, [rsp+32]
    mov     edi, 1
    sub     rdx, rax
    xor     eax, eax
    lea     rsi, [rsp+32+rdx]
    mov     rdx, r8
    mov     rax, 1
    syscall
    add     rsp, 40
    ret
"""
	code += '_start:\n'

	# If there is a main function (if there isn't there's a bunch of unused code)
	#if list(filter(lambda x: x.id == 'main', prog.functions)) == []:
	#	compilationError("'main' procedure does not exist")
		
	code += '    call    _main_\n'

	code += '    xor     rdi, rdi\n'
	code += '    mov     rax, 60\n'
	code += '    syscall\n'
	code += '_main_:\n'

	dataLabels = []
	# [{'counter': 5, 'loop': False}, {'counter': 1, 'loop': True}]
	# depth: 2
	depthCounters = []
	labelDepth = 0
	for word in words:
		if word.type == 'CONST':
			if word.value_type == 'INT':
				code +=  '\n    ;; -- CONST INT -- ;;\n'
				code += f'    push    {word.value}\n'
				#code += f'    mov     rax, {word.value}\n'
				#code +=  '    push    rax\n'

			elif word.value_type == 'STRING':
				label = 'D' + str(len(dataLabels))
				dataLabels.append({'label': label, 'data': word.value})
				size = len(word.value)
				code +=  '\n    ;; -- CONST STRING -- ;;\n'
				code += f'    push    {size}\n'
				code += f'    push    {label}\n'

			elif word.value_type == 'CHARACTER':
				code +=  '\n    ;; -- CONST CHAR -- ;;\n'
				code += f'    push    {word.value}\n'

			else:
				syntaxError(word, f"ERROR: unknown const type '{word.value_type}'")
				
		elif word.type == 'WORD':
			#print(f"Generating word '{word.op}'")
			if word.op == 'ADD':
				code += '\n    ;; -- ADD -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rax\n'
				code += '    add     rax, rcx\n'
				code += '    push    rax\n'
			elif word.op == 'SUB':
				code += '\n    ;; -- SUB -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    sub     rcx, rax\n'
				code += '    push    rcx\n'
			elif word.op == 'BINARY_OR':
				code += '\n    ;; -- BINARY_OR -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rbx\n'
				code += '    or      rbx, rax\n'
				code += '    push    rbx\n'
			elif word.op == 'BINARY_AND':
				code += '\n    ;; -- BINARY_AND -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rbx\n'
				code += '    and     rbx, rax\n'
				code += '    push    rbx\n'
				
			elif word.op == 'SHIFT_LEFT':
				code += '\n    ;; -- SHIFT_LEFT -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rbx\n'
				code += '    shl     rbx, cl\n'
				code += '    push    rbx\n'
				
			elif word.op == 'SHIFT_RIGHT':
				code += '\n    ;; -- SHIFT_RIGHT -- ;;\n'
				code += '    pop     rcx\n'
				code += '    pop     rbx\n'
				code += '    shr     rbx, cl\n'
				code += '    push    rbx\n'
				
			elif word.op == 'DUMP':
				code += '\n    ;; -- DUMP -- ;;\n'
				code += '    pop     rdi\n'
				code += '    call    dump\n'
				
			elif word.op == 'EQU':
				code += '\n    ;; -- EQU -- ;;\n'
				code += '    xor     rdx, rdx\n'
				code += '    mov     rbx, 1\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    cmp     rax, rcx\n'
				code += '    cmove   rdx, rbx\n'
				code += '    push    rdx\n'
				
			elif word.op == 'DUP':
				code += '\n    ;; -- DUP -- ;;\n'
				code += '    pop     rax\n'
				code += '    push    rax\n'
				code += '    push    rax\n'
				
			elif word.op == '2DUP':
				code += '\n    ;; -- 2DUP -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    push    rcx\n'
				code += '    push    rax\n'
				code += '    push    rcx\n'
				code += '    push    rax\n'
				
			elif word.op == 'SWAP':
				code += '\n    ;; -- SWAP -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    push    rax\n'
				code += '    push    rcx\n'
				
			elif word.op == 'DROP':
				code += '\n    ;; -- DROP -- ;;\n'
				code += '    pop     rax\n'
				
			elif word.op == 'OVER':
				code += '\n    ;; -- OVER -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    push    rax\n'
				code += '    push    rcx\n'
				code += '    push    rax\n'
				
			elif word.op == 'GREATER_THAN':
				code += '\n    ;; -- GREATER_THAN -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    xor     rdx, rdx\n'
				code += '    mov     rbx, 1\n'
				code += '    cmp     rcx, rax\n'
				code += '    cmovg   rdx, rbx\n'
				code += '    push    rdx\n'
				
			elif word.op == 'LESS_THAN':
				code += '\n    ;; -- LESS_THAN -- ;;\n'
				code += '    pop     rax\n'
				code += '    pop     rcx\n'
				code += '    xor     rdx, rdx\n'
				code += '    mov     rbx, 1\n'
				code += '    cmp     rcx, rax\n'
				code += '    cmovl   rdx, rbx\n'
				code += '    push    rdx\n'
				
			elif word.op == 'MEM':
				code += '\n    ;; -- MEM -- ;;\n'
				code += '    push    mem\n'
				
			elif word.op == 'LOAD':
				code += '\n    ;; -- LOAD -- ;;\n'
				code += '    pop     rax\n'
				code += '    xor     rbx, rbx\n'
				code += '    mov     bl, [rax]\n'
				code += '    push    rbx\n'
				
			elif word.op == 'STORE':
				code += '\n    ;; -- STORE -- ;;\n'
				code += '    pop     rbx\n'  # 97
				code += '    pop     rax\n'  # mem
				code += '    mov     [rax], bl\n' # Move lower 8 bits into mem
				
			elif word.op == 'SYSCALL1':
				code += '\n    ;; -- SYSCALL1 -- ;;\n'
				code += '    pop rax\n'
				code += '    pop rdi\n'
				code += '    syscall\n'
				
			elif word.op == 'SYSCALL3':
				code += '\n    ;; -- SYSCALL3 -- ;;\n'
				code += '    pop rax\n'
				code += '    pop rdi\n'
				code += '    pop rsi\n'
				code += '    pop rdx\n'
				code += '    syscall\n'
				
			else:
				syntaxError(tok, f"ERROR: unreckognized word '{word.op}'")
		elif word.type == 'KEYWORD':
			if word.op == 'WHILE':
				labelDepth += 1
				while len(depthCounters) <= labelDepth:
					depthCounters.append(Depth(labelDepth))
				depthCounters[labelDepth].loop = True
				while_label = depthCounters[labelDepth].nextLabel()
				code += '\n;; -- WHILE -- ;;\n'
				code += f'{while_label}:\n'
				
			elif word.op == 'DO':
				do_label = depthCounters[labelDepth].nextLabel()
				end_label = depthCounters[labelDepth].nextLabel()
				code += '\n;; -- DO -- ;;\n'
				code += f'{do_label}:\n'
				code +=  '    pop     rax\n'
				code +=  '    test    rax, rax\n'
				code += f'    jz      {end_label}\n'
				
			elif word.op == 'IF':
				labelDepth += 1
				while len(depthCounters) <= labelDepth:
					depthCounters.append(Depth(labelDepth))
				label = depthCounters[labelDepth].nextLabel()
				code +=  '\n    ;; -- IF -- ;;\n'
				code +=  '    pop     rax\n'
				code +=  '    test    rax, rax\n'
				code += f'    jz      {label}\n'
				code +=  '    ;; --- If body goes here --- ;;\n'
				
			elif word.op == 'ELSE':
				else_label = depthCounters[labelDepth].label()
				tmp_label = depthCounters[labelDepth].nextLabel()
				end_label = depthCounters[labelDepth].nextLabel()
				code +=  '\n;; -- ELSE -- ;;\n'
				code += f'{tmp_label}:\n'
				code += f'    jmp {end_label}\n'
				code += f'{else_label}:\n'
				
			elif word.op == 'END':
				label = depthCounters[labelDepth].label()
				code += '\n;; -- END -- ;;\n'
				if depthCounters[labelDepth].loop:
					depthCounters[labelDepth].counter -= 2
					while_label = depthCounters[labelDepth].label()
					depthCounters[labelDepth].counter += 2
					code += f'    jmp     {while_label}\n'
				code += f'{label}: ; end_label\n'
				labelDepth -= 1

			elif word.op == 'INCLUDE':
				syntaxError(word, f"ERROR: there shouldn't be an include here! It's probably a bug in the compiler")

			else:
				syntaxError(word, f"ERROR: unreckognized word type: '{word.type}' with word: '{word.op}'")

	code += '    ret\n'
	
	code += '\nsection .bss\n'
	code += 'mem:\n'
	code += '    resb    4096\n'

	code += '\nsection .text\n'
	
	for data in dataLabels:
		data_bytes = ','.join(map(hex, bytes(data['data'], 'utf-8')))
		code += f'{data["label"]}:\n'
		code += f'    db      {data_bytes}\n'
	
	return code
		
def main():
	arguments = parse_args()

	# Help if --help or no arguments
	if arguments.help or arguments.none:
		print(help_message)
		exit()

	# No input file
	if not arguments.infn:
		fail('no input files supplied')

	# Infile doesn't exist
	if not os.path.isfile(arguments.infn):
		fail(f"{arguments.infn}: No such file or directory")

	start = time.time()
	
	tokens = lexFile(arguments.infn)

	# Type checking ...	

	words = parse(tokens)

	words = preprocess(words, arguments)
	
	# Pretty printing
	if arguments.pretty:
		pretty_print(prog)

	code = generateProgram(words)

	end = time.time()

	print(f'[INFO] Compiling took {end-start:0.5f}s')
	
	tmp_asm = '.tmp_bip_bop.s'
	tmp_o = '.tmp_bip_bop.o'
	
	# Write the generated assembly code to the file
	with open(tmp_asm, 'w') as asmfile:
		asmfile.write(code)
		asmfile.close()

	if arguments.asm:
		os.rename(tmp_asm, arguments.outfn)
		return

	nasm_args = ['nasm', '-f', 'elf64', '-o', tmp_o, tmp_asm]
	ld_args = ['ld', '-o', arguments.outfn, tmp_o]
	
	start = time.time()

	print("[CMD]", ' '.join(nasm_args))
	nasm = subprocess.Popen(nasm_args)
	nasm.communicate()

	if nasm.returncode != 0:
		exit(1)

	print("[CMD]", ' '.join(ld_args))
	ld = subprocess.Popen(ld_args)
	ld.communicate()

	if ld.returncode != 0:
		exit(1)
	
	end = time.time()

	print(f'[INFO] Assembling took {end-start:0.5f}s')

	os.remove(tmp_asm)
	os.remove(tmp_o)

	if arguments.run:
		fn_to_run = './' + arguments.outfn
		print(f"Running '{fn_to_run}'\n")
		# Segmentation fault show show?
		process = subprocess.Popen([fn_to_run])
		process.communicate()

		if process.returncode == 0:
			print("\nProcess exited normally with exit code 0")
			os.remove(arguments.outfn)
		else:
			print(f"\nProcess exited abnormally with exit code {process.returncode}")
		
if __name__ == "__main__":
	main()
	exit(0)
