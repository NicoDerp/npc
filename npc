#!/usr/bin/python3

# rework branch

import sys, os, re
import itertools
import subprocess
import time

# source_re = r"int main\s*\(\s*\)\s*{\s*return\s+(?P<ret>[0-9]+)\s*;\s*}"

# hex: 0[xX][0-9a-fA-F]+

# Bakkes-Naur
# <program> ::= <function>
# <function> ::= "fun" <id> "" <statement> "}"
# <statement> ::= "return" <exp> ";"
# <exp> ::= <logical-and-exp> { ("||" | "|") <logical-and-exp> }
# <logical-and-exp> ::= <equality-exp> { ("&&" | "&" | "^") <equality-exp> }
# <equality-exp> ::= <relational-exp> { ("!=" | "==" ) <relational-exp> }
# <relational-exp> ::= <additive-exp> { ("<" | ">" | "<=" | ">=") <additive-exp> }
# <additive-exp> ::= <term> { ("+" | "-") <term> }
# <term> ::= <factor> { ("*" | "/" | "%") <factor> }
# <factor> ::= "(" <exp> ")" | <unary-op> <factor> | <int>
# <unary-op> ::= "!" | "~" | "-"

# Keywords regex
lexing_keywords = r"([a-zA-Z]+|\d|\+)"

# For function names
function_name_regex = r"[a-zA-Z]\w*"

# Help message
help_message ="""\
Usage: npc file [options]

Options:
  -o <file>    Place the output into file
  -p           Pretty-print the AST of the program
  -S           Do not assemble, output is assembly code
  -r           Run the program after a succesful compilation
  -h           Display this information and exit"""

base_asm = """\
.text
.globl main
main:
"""
#    movl    ${}, %eax
#    ret


class Arguments:
	def __init__(self):
		self.infn = None
		self.outfn = 'a.out'
		self.pretty = None
		self.help = None
		self.none = None
		self.asm = None
		self.run = None
		
class Classified:
	def __init__(self, type):
		self.type = type

class Function(Classified):
	def __init__(self, id, words): # params
		super().__init__("FUNCTION")
		self.id = id
		self.words = words

class Program(Classified):
	def __init__(self, functions):
		super().__init__("PROGRAM")
		self.functions = functions

class Const(Classified):
	def __init__(self, value_type, value):
		super().__init__("CONST")
		self.value_type = value_type
		self.value = value

class Word(Classified):
	def __init__(self, op):
		super().__init__("WORD")
		self.op = op

class Token():
	def __init__(self, token, row, col, filepath):
		self.token = token
		self.row = row
		self.col = col
		self.filepath = filepath
	
def fail(err):
	print('Error:', err)
	exit(1)
	
def syntaxError(tok, err):
	tok.row += 1 if tok.row != 0 else 0  # Since emacs is dum dum
	print(f"{tok.filepath}:{tok.row}:{tok.col}: {err}")
	exit(1)

def lex(source_file):
	# Read and get matches from regex
	with open(source_file, 'r') as infile:
		#source = infile.read().strip()
		#matches = re.findall(lexing_keywords, source)
		matches = [((token.start(), token.group()) for token in re.finditer(r"\S+", line)) for line in infile.readlines()]
		
	# Filter out '' in the list, could probably be done easier in the regex
	#matches = list(filter(lambda x: x != '', matches))
	
	for row, i in enumerate(matches):
		for col, tok in i:
			#print(f"Row: {row}, Col: {col}, Token: {tok}")
			yield Token(tok, row, col, source_file)
			
	# Yield tokens (creates a generator)
	#for match in matches:
	#	yield match.replace(' ', '') # No tokens should have spaces in them

def parseWord(tok):	
	if tok.token == '+':
		return Word('ADD')

	elif tok.token == '-':
		return Word('SUB')

	elif tok.token == '.':
		return Word('DUMP')

	elif tok.token == '=':
		return Word('EQU')

	elif tok.token == 'if':
		return Word('IF')

	elif tok.token == 'else':
		return Word('ELSE')

	elif tok.token == 'end':
		return Word('END')

	elif tok.token == 'dup':
		return Word('DUP')
	
	elif tok.token == 'swap':
		return Word('SWAP')

	elif tok.token == '>':
		return Word('GREATER_THAN')

	elif tok.token == '<':
		return Word('LESS_THAN')

	elif tok.token == 'while':
		return Word('WHILE')

	elif tok.token == 'do':
		return Word('DO')
	
	else:
		try:
			return Const('INT', int(tok.token))
		except ValueError as err:
			syntaxError(tok, err)
			
def parseFunction(tokens):
	tok = next(tokens)
	if tok.token != 'fun':
		syntaxError(tok, f"got token '{tok}', but expected 'fun'")

	id = next(tokens).token

	# Invalid function name
	#if not re.match(function_name_regex, id):
	#	fail()

	tok = next(tokens)
	if tok.token != 'in':
		syntaxError(tok, f"got token '{tok}', but expected 'in'")

	# Support for multiple statements
	# statement = None
	# while True:
	#   statement = ...
	#   if nextToken==None: EOF, fail()
	#   if nextToken=='}': break
	words = []

	depth = 1
	while True:
		tok = next(tokens)

		if tok.token == 'if' or tok.token == 'while':
			depth += 1
		elif tok.token == 'end':
			depth -= 1
		if depth == 0:
			break
		
		word = parseWord(tok)
		words.append(word)

	function = Function(id, words)

	return function

def parse(tokens):
	function = parseFunction(tokens)
	program = Program([function])
	return program


def pretty_print(obj, n=0):
	space = '    '
	print('Wiiu')
	
def parse_args():
	argv = (x for x in sys.argv)
	arguments = Arguments() # Put default values here

	# No arguments so skip and save
	if len(sys.argv) == 1:
		arguments.none = True
		return arguments

	# Since the first one is npc, the second is the file name
	next(argv)

	first = next(argv)
	if first == '--help':
		arguments.help = True
		return arguments

	arguments.infn = first

	while True:
		try:
			arg = next(argv)
		except:
			break

		# print("Arg:", arg)

		if arg == '-p':
			arguments.pretty = True

		elif arg == '-S':
			arguments.asm = True

		elif arg == '-r':
			arguments.run = True
			
		elif arg == '-o':
			try:
				arg = next(argv)
			except:
				fail("missing filename after '-o'")

			arguments.outfn = arg

		# Unreckgnised argument
		else:
			fail("unreckognized argument '{arg}'")

	return arguments

labelCounters = []
labelDepth = 0
labelInfo = []

def generateLabel():
	global labelCounters, labelDepth
	if len(labelCounters) >= labelDepth:
		labelCounters.append(0)
	labelCounters[labelDepth] += 1
	return f".L{str(labelDepth)}.{str(labelCounters[labelDepth])}"

def currentLabel():
	global labelCounters, labelDepth
	return f".L{str(labelDepth)}.{str(labelCounters[labelDepth])}"

def previousLabel():
	global labelCounters
	labelCounters[labelDepth] -= 1
	return f".L{str(labelDepth)}.{str(labelCounters[labelDepth])}"

def increaseDepth():
	global labelDepth
	labelDepth += 1

def decreaseDepth():
	global labelDepth
	labelDepth -= 1

def getLabelInfo():
	global labelInfo, labelDepth
	while len(labelInfo) <= labelDepth:
		labelInfo.append({'loop': False})
	return labelInfo[labelDepth]
	
def generateWord(word):	
	code = ''
	if word.type == 'CONST':
		code += f'    mov     rax, {word.value}\n'
		code +=  '    push    rax\n'
	
	elif word.type == 'WORD':
		#print(f"Generating word '{word.op}'")
		if word.op == 'ADD':
			code += '    pop     rcx\n'
			code += '    pop     rax\n'
			code += '    add     rax, rcx\n'
			code += '    push    rax\n'
			
		elif word.op == 'SUB':
			code += '    pop     rax\n'
			code += '    pop     rcx\n'
			code += '    sub     rcx, rax\n'
			code += '    push    rcx\n'

		elif word.op == 'DUMP':
			code += '    pop     rdi\n'
			code += '    call    dump\n'

		elif word.op == 'EQU':
			code += '    xor     rdx, rdx\n'
			code += '    mov     rbx, 1\n'
			code += '    pop     rax\n'
			code += '    pop     rcx\n'
			code += '    cmp     rax, rcx\n'
			code += '    cmove   rdx, rbx\n'
			code += '    push    rdx\n'

		elif word.op == 'IF':
			increaseDepth()
			label = generateLabel()
			code +=  '    pop     rax\n'
			code +=  '    test    rax, rax\n'
			code += f'    jz      {label}\n'
			code +=  '    ;; --- If body goes here --- ;;\n'

		elif word.op == 'ELSE':
			else_label = currentLabel()
			tmp_label = generateLabel()
			end_label = generateLabel()
			code += f'{tmp_label}:\n'
			code += f'    jmp {end_label}\n'
			code += f'{else_label}:\n'
			
		elif word.op == 'END':
			label = currentLabel()
			if getLabelInfo()['loop']:
				previousLabel()
				while_label = previousLabel()
				generateLabel()
				generateLabel()
				code += f'    jmp     {while_label}\n'
			code += f'{label}: ; end_label\n'
			decreaseDepth()

		elif word.op == 'DUP':
			code += '    pop     rax\n'
			code += '    push    rax\n'
			code += '    push    rax\n'

		elif word.op == 'SWAP':
			code += '    pop     rax\n'
			code += '    pop     rcx\n'
			code += '    push    rax\n'
			code += '    push    rcx\n'

		elif word.op == 'GREATER_THAN':
			code += '    pop     rax\n'
			code += '    pop     rcx\n'
			code += '    xor     rdx, rdx\n'
			code += '    mov     rbx, 1\n'
			code += '    cmp     rcx, rax\n'
			code += '    cmovg   rdx, rbx\n'
			code += '    push    rdx\n'

		elif word.op == 'LESS_THAN':
			code += '    pop     rax\n'
			code += '    pop     rcx\n'
			code += '    xor     rdx, rdx\n'
			code += '    mov     rbx, 1\n'
			code += '    cmp     rcx, rax\n'
			code += '    cmovl   rdx, rbx\n'
			code += '    push    rdx\n'

		elif word.op == 'WHILE':
			increaseDepth()
			getLabelInfo()['loop'] = True
			while_label = generateLabel()
			code += f'{while_label}:  ; while_label\n'
			
		elif word.op == 'DO':
			do_label = generateLabel()
			end_label = generateLabel()
			code += f'{do_label}:  ; do_label\n'
			code +=  '    pop     rax\n'
			code +=  '    test    rax, rax\n'
			code += f'    jz      {end_label}\n'
		else:
			compilationError(tok, f"unreckognized word '{word}'")

	else:
		compilationError(tok, f"unreckognized word '{word}'")
		
	return code

def generateFunction(func):
	code = f'{func.id}:\n'
	for word in func.words:
		code += generateWord(word)
	code += '    ret\n'
	return code

def generateProgram(prog):
	code =  'section .text\n'
	code += 'global _start\n'
	label = generateLabel()

	code += f"""\
dump:
    mov     r9, -3689348814741910323
    sub     rsp, 40
    mov     BYTE [rsp+31], 10
    lea     rcx, [rsp+30]
{label}:
    mov     rax, rdi
    lea     r8, [rsp+32]
    mul     r9
    mov     rax, rdi
    sub     r8, rcx
    shr     rdx, 3
    lea     rsi, [rdx+rdx*4]
    add     rsi, rsi
    sub     rax, rsi
    add     eax, 48
    mov     BYTE [rcx], al
    mov     rax, rdi
    mov     rdi, rdx
    mov     rdx, rcx
    sub     rcx, 1
    cmp     rax, 9
    ja      {label}
    lea     rax, [rsp+32]
    mov     edi, 1
    sub     rdx, rax
    xor     eax, eax
    lea     rsi, [rsp+32+rdx]
    mov     rdx, r8
    mov     rax, 1
    syscall
    add     rsp, 40
    ret
"""
	code += '_start:\n'
	code += '    call    main\n'
	#code += '    mov     rdi, rax\n'
	code += '    xor     rdi, rdi\n'
	code += '    mov     rax, 60\n'
	code += '    syscall\n'
	for func in prog.functions:
		code += generateFunction(func)
	return code
		
def main():
	arguments = parse_args()

	# Help if --help or no arguments
	if arguments.help or arguments.none:
		print(help_message)
		exit()

	# No input file
	if not arguments.infn:
		fail('no input files supplied')

	# Infile doesn't exist
	if not os.path.isfile(arguments.infn):
		fail(f"{arguments.infn}: No such file or directory")

	start = time.time()
	
	tokens = lex(arguments.infn)

	# Type checking ...	

	prog = parse(tokens)

	# Pretty printing
	if arguments.pretty:
		pretty_print(prog)

	code = generateProgram(prog)

	end = time.time()

	print(f'[INFO] Compiling took {end-start:0.5f}s')
	
	tmp_asm = '.tmp_bip_bop.s'
	tmp_o = '.tmp_bip_bop.o'
	
	# Write the generated assembly code to the file
	with open(tmp_asm, 'w') as asmfile:
		asmfile.write(code)
		asmfile.close()

	if arguments.asm:
		os.rename(tmp_asm, arguments.outfn)
		return
	
	start = time.time()
	nasm = subprocess.Popen(['nasm', '-f', 'elf64', '-o', tmp_o, tmp_asm])
	nasm.communicate()

	if nasm.returncode != 0:
		exit(1)
	
	ld = subprocess.Popen(['ld', '-o', arguments.outfn, tmp_o])
	ld.communicate()

	if ld.returncode != 0:
		exit(1)
	
	end = time.time()

	print(f'[INFO] Assembling took {end-start:0.5f}s')

	os.remove(tmp_asm)
	os.remove(tmp_o)

	if arguments.run:
		print(f"Running '{arguments.outfn}'\n")
		subprocess.Popen(['./' + arguments.outfn]).communicate()
		os.remove(arguments.outfn)
		
if __name__ == "__main__":
	main()
