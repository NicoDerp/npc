#!/usr/bin/python3

import sys, os, re
import itertools

# source_re = r"int main\s*\(\s*\)\s*{\s*return\s+(?P<ret>[0-9]+)\s*;\s*}"

# hex: 0[xX][0-9a-fA-F]+

# Bakkes-Naur
# <program> ::= <function>
# <function> ::= "int" <id> "(" ")" "{" <statement> "}"
# <statement> ::= "return" <exp> ";"
# <exp> ::= <logical-and-exp> { "||" <logical-and-exp> }
# <logical-and-exp> ::= <equality-exp> { "&&" <equality-exp> }
# <equality-exp> ::= <relational-exp> { ("!=" | "==" ) <relational-exp> }
# <relational-exp> ::= <additive-exp> { ("<" | ">" | "<=" | ">=") <additive-exp> }
# <additive-exp> ::= <term> { ("+" | "-") <term> }
# <term> ::= <factor> { ("*" | "/") <factor> }
# <factor> ::= "(" <exp> ")" | <unary-op> <factor> | <int>
# <unary-op> ::= "!" | "~" | "-"

# Keywords regex                              chars      ints
lexing_keywords = r"({|}|\(|\)|;|int|return|[a-zA-Z]\w*|[.[0-9]+|-|~|![^=]|\+|\*|\/|&&|\|\||==|!=|<[^=]|<=|>[^=]|>=)"

# For function names
function_name_regex = r"[a-zA-Z]\w*"

# Help message
help_message ="""\
Usage: npc file [options]

Options:
  -o <file>    Place the output into file.
  -p           Pretty-print the AST of the program.
  -S           Do not assemble, output is assembly code.
  -h           Display this information and exit."""

base_asm = """\
.text
.globl main
main:
"""
#    movl    ${}, %eax
#    ret


class Arguments:
	def __init__(self):
		self.infn = None
		self.outfn = None
		self.asmfn = None
		self.pretty = None
		self.help = None
		self.none = None
		self.asm = None

class Token:
	def __init__(self, type):
		self.type = type

class Function(Token):
	def __init__(self, id, returnType, body): # params
		super().__init__("FUNCTION")
		self.id = id
		self.returnType = returnType
		self.body = body

class Program(Token):
	def __init__(self, functions):
		super().__init__("PROGRAM")
		self.functions = functions

# class Statement(Token):
# 	def __init__()

class Return(Token):
	def __init__(self, exp):
		super().__init__("RETURN")
		self.exp = exp

class Const(Token):
	def __init__(self, value_type, value):
		super().__init__("CONST")
		self.value_type = value_type
		self.value = value

class UnaryOperator(Token):
	def __init__(self, operator):
		super().__init__("UNARY_OPERATOR")
		self.operator = operator

class UnOp(Token):
	def __init__(self, op, value):
		super().__init__("UNOP")
		self.op = op
		self.value = value

class BinaryOperator(Token):
	def __init__(self, operator):
		super().__init__("BINARY_OPERATOR")
		self.operator = operator

class BinOp(Token):
	def __init__(self, op, left, right):
		super().__init__("BINOP")
		self.op = op
		self.left = left
		self.right = right

class Body(Token):
	def __init__(self, statements):
		super().__init__("BODY")
		self.statements = statements


def fail():
	raise Exception("Error")


def lex(source_file):
	# Read and get matches from regex
	with open(source_file, 'r') as infile:
		source = infile.read().strip()
		matches = re.findall(lexing_keywords, source)

	# Filter out '' in the list, could probably be done easier in the regex
	matches = list(filter(lambda x: x != '', matches))

	# print(matches)

	# Yield tokens (creates a generator)
	for match in matches:
		yield match.replace(' ', '') # No tokens should have spaces in them


def tokenType(token):
	try:
		int(token)
		return "INT"
	except Exception as e: pass
	return "STRING"

def parseUnaryOperator(tok):
	if tok == '-':
		return UnaryOperator('NEGATE')

	elif tok == '!':
		return UnaryOperator('LOGICAL_NEGATE')

	elif tok == '~':
		return UnaryOperator('BITWISE_COMPLEMENT')

	else:
		fail()

def parseBinaryOperator(tok):
	if tok == '+':
		return BinaryOperator('ADD')

	elif tok == '-':
		return BinaryOperator('SUBTRACT')

	elif tok == '*':
		return BinaryOperator('MULTIPLY')

	elif tok == '/':
		return BinaryOperator('DIVIDE')

	elif tok == '&&':
		return BinaryOperator('AND')

	elif tok == '||':
		return BinaryOperator('OR')

	elif tok == '==':
		return BinaryOperator('EQUAL')

	elif tok == '!=':
		return BinaryOperator('NOT_EQUAL')

	elif tok == '<':
		return BinaryOperator('LESS_THAN')

	elif tok == '<=':
		return BinaryOperator('LESS_THAN_OR_EQUAL')

	elif tok == '>':
		return BinaryOperator('GREATER_THAN')

	elif tok == '>=':
		return BinaryOperator('GREATER_THAN_OR_EQUAL')

	else:
		fail()

def isUnop(tok):
	return tok in ['-', '!', '~']

def parseFactor(tokens):
	tok = next(tokens)
	if tok == '(':
		# <factor> ::= "(" <exp> ")"

		tokens, exp = parseExpression(tokens)

		tok = next(tokens)
		if tok != ')':
			fail()

		return exp

	elif isUnop(tok):
		# <factor> ::= <unary_op> <factor>
		op = parseUnaryOperator(tok)
		factor = parseFactor(tokens) # Recursion, again!
		return UnOp(op, factor)

	elif tok.isnumeric():
		# <factor> ::= <int>
		return Const('INT', int(tok))

	else:
		fail()

def parseTerm(tokens):
	factor = parseFactor(tokens)
	tok = next(tokens)
	tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	while tok == '*' or tok == '/':  # Another factor!
		op = parseBinaryOperator(next(tokens))
		next_factor = parseFactor(tokens)
		factor = BinOp(op, factor, next_factor)
		tok = next(tokens)
		tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	return tokens, factor

def parseAdditiveExp(tokens):
	tokens, term = parseTerm(tokens)
	tok = next(tokens)
	tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	while tok == '+' or tok == '-':  # Another one!
		op = parseBinaryOperator(next(tokens))
		tokens, next_term = parseTerm(tokens)
		term = BinOp(op, term, next_term)
		tok = next(tokens)
		tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	return tokens, term


def parseRelationalExp(tokens):
	tokens, additiveExp = parseAdditiveExp(tokens)
	tok = next(tokens)
	tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	while tok == '<' or tok == '>' or tok == '<=' or tok == '>=':  # Another one!
		op = parseBinaryOperator(next(tokens))
		tokens, next_additiveExp = parseAdditiveExp(tokens)
		additiveExp = BinOp(op, additiveExp, next_additiveExp)
		tok = next(tokens)
		tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	return tokens, additiveExp


def parseEqualityExp(tokens):
	tokens, relationalExp = parseRelationalExp(tokens)
	tok = next(tokens)
	tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	while tok == '==' or tok == '!=':  # Another one!
		op = parseBinaryOperator(next(tokens))
		tokens, next_relationalExp = parseRelationalExp(tokens)
		relationalExp = BinOp(op, relationalExp, next_relationalExp)
		tok = next(tokens)
		tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	return tokens, relationalExp


def parseLogicalAndExp(tokens):
	tokens, equalityExp = parseEqualityExp(tokens)
	tok = next(tokens)
	tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	while tok == '&&':  # Another one!
		op = parseBinaryOperator(next(tokens))
		tokens, next_equalityExp = parseEqualityExp(tokens)
		equalityExp = BinOp(op, equalityExp, next_equalityExp)
		tok = next(tokens)
		tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	return tokens, equalityExp


def parseExpression(tokens):
	tokens, lae = parseLogicalAndExp(tokens)
	tok = next(tokens)
	tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	while tok == '||':  # There's another term!
		op = parseBinaryOperator(next(tokens))
		tokens, next_lae = parseLogicalAndExp(tokens)
		lae = BinOp(op, lae, next_lae)
		tok = next(tokens)
		tokens = itertools.chain([tok], tokens)  # Bad hack for peek()

	return tokens, lae

#def parseExpression(tokens):
#	tok = next(tokens)
#
#	# Is the token a number
#	if tok.isnumeric():
#		return Const("INT", int(tok))
#	else:
#		op = parseUnaryOperator(tok) # Convert token to UnaryOperator element, will fail if isn't '-', '!' or '~'
#		inner_exp = parseExpression(tokens) # Recursion!!
#		return UnOp(op, inner_exp)


def parseStatement(tokens):
	tok = next(tokens)

	if tok != "return":
		fail()

	tokens, exp = parseExpression(tokens)

	statement = Return(exp)

	tok = next(tokens)
	if tok != ";":
		fail()
	return statement


def parseFunction(tokens):
	returnType = next(tokens)
	id = next(tokens)

	# Invalid function name
	if not re.match(function_name_regex, id):
		fail()

	tok = next(tokens)
	if tok != '(':
		fail()

	# Function parameters here

	tok = next(tokens)
	if tok != ')':
		fail()

	tok = next(tokens)
	if tok != '{':
		fail()

	# Support for multiple statements
	# statement = None
	# while True:
	#   statement = ...
	#   if nextToken==None: EOF, fail()
	#   if nextToken=='}': break

	statement = parseStatement(tokens)
	function = Function(id, returnType, Body([statement]))

	tok = next(tokens)
	if tok != '}':
		fail()

	return function

def parse(tokens):

	# Shouldn't be anything else yet
	#if tok == "int":

	function = parseFunction(tokens)
	program = Program([function])
	return program


def pretty_print(obj, n=0):
	space = '    '
	if obj.type == "PROGRAM":
		print("PROGRAM:")
		for func in obj.functions:
			pretty_print(func, n+1)

	elif obj.type == "FUNCTION":
		print(space*(n+0) + f"FUN {obj.returnType} {obj.id}:")
		print(space*(n+1) +  "params: ()") # None yet
		print(space*(n+1) +  "body:")
		pretty_print(obj.body, n+1)

	elif obj.type == "BODY":
		for statement in obj.statements:
			if statement.type == "RETURN":
				pretty_print(statement.exp, n+1)
			else:
				print(space*(n+2) + f"{statement.type} ???")

	elif obj.type == "UNOP":
		print(space*(n+0) + f"UNOP<{obj.op.operator}, {obj.value.type}>")
		pretty_print(obj.value, n+1)

	elif obj.type == "BINOP":
		print(space*(n+0) + f"BINOP<{obj.left.type}, {obj.op.operator}, {obj.right.type}>")
		pretty_print(obj.left, n+1)
		pretty_print(obj.op, n+1)
		pretty_print(obj.right, n+1)

	elif obj.type == "CONST":
		print(space*n + f"CONST<{obj.value_type}<{obj.value}>>")

def parse_args():
	argv = (x for x in sys.argv)
	arguments = Arguments() # Put default values here

	# No arguments so skip and save
	if len(sys.argv) == 1:
		arguments.none = True
		return arguments

	# Since the first one is npc, the second is the file name
	next(argv)

	first = next(argv)
	if first == '--help':
		arguments.help = True
		return arguments

	arguments.infn = first

	while True:
		try:
			arg = next(argv)
		except:
			break

		# print("Arg:", arg)

		if arg == '-p':
			arguments.pretty = True

		elif arg == '-S':
			arguments.asm = True

		elif arg == '-o':
			try:
				arg = next(argv)
			except:
				fail()

			arguments.outfn = arg

		# Unreckgnised argument
		else:
			fail()

	return arguments

def generateUnOpBase(obj):
	tmp = obj.value
	while tmp.type != "CONST":
		tmp = tmp.value

	return f"    movl    ${tmp.value}, %eax	# Return value\n"

labelCounter = 0

def generateLabel():
	global labelCounter
	labelCounter += 1
	return "L" + str(labelCounter)

def generate(obj):
	code = ''
	if obj.type == "PROGRAM":
		code += base_asm
		for func in obj.functions:
			code += generate(func)

	if obj.type == "FUNCTION":
		for statement in obj.body.statements:
			if statement.type == "RETURN":
				if statement.exp.type == "CONST":
					code += f"    movl    ${statement.exp.value}, %eax\n"

				elif statement.exp.type == "UNOP":
					code += generateUnOpBase(statement.exp)
					code += generate(statement.exp)

				elif statement.exp.type == "BINOP":
					code += generate(statement.exp)
					#code += "    push    %eax  # save value of e1 on the stack\n"
					#code += "    pop    %ecx  # pop e1 from the stack into ecx\n"

				code += "    ret\n"
			else:
				fail()

	if obj.type == "UNOP":
		if obj.value.type == "UNOP":
			code += generate(obj.value)

		if obj.op.operator == "NEGATE":
			code += """\
    neg     %eax          # eax negated
"""

		if obj.op.operator == "LOGICAL_NEGATE":
			code += f"""\
    cmpl    $0, %eax	# set ZF on if exp == 0, set it off otherwize
    mov     $0, %eax	# clear eax
    sete    %al		# set al register (the lower byte of eax) to 1 if ZF is on
"""
#     xor     %eax, %eax    # zero out eax (doesn't change flags)
# Can't use it even though it's better because it sets the zero flag

		if obj.op.operator == "BITWISE_COMPLEMENT":
			code += """\
    not     %eax          # eax bitwise compliment
"""

	if obj.type == "BINOP":
		if obj.right.type == "BINOP":
			code += generate(obj.right)
		elif obj.right.type == "UNOP":
			code += generateUnOpBase(obj.right)
			code += generate(obj.right)
		else:
			code += f"""\
    movl    ${obj.right.value}, %eax	# mov right value to eax
"""
		code += "    pushl   %eax	# push eax\n"

		if obj.left.type == "BINOP":
			code += generate(obj.left)
		elif obj.left.type == "UNOP":
			code += generateUnOpBase(obj.left)
			code += generate(obj.left)
		else:
			code += f"""\
    movl    ${obj.left.value}, %eax	# mov left value to eax
"""


		if obj.op.operator != "AND" and obj.op.operator != "OR":
			code += "    popl    %ecx	# pop to ecx (eax->ecx)\n"

		if obj.op.operator == "ADD":
			code += """\
    addl    %ecx, %eax	# e1 + e2
"""
		if obj.op.operator == "SUBTRACT":
			code += """\
    subl    %ecx, %eax	# e2 - e1
"""

		if obj.op.operator == "MULTIPLY":
			code += """\
    imul    %ecx, %eax  # e1 * e2
"""

		if obj.op.operator == "DIVIDE":
			code += """\
    cdq			# edx:eax = 32 bit divident
    idivl   %ecx	# divide edx:eax by ecx, quotient is stored in eax, remainder in edx
"""

		if obj.op.operator == "AND":
			clause = generateLabel()
			end = generateLabel()

			code += f"""\
    # Code for e1
    cmpl    $0, %eax
    jne     {clause}
    addl    $4, %esp
    jmp     {end}
{clause}:
	# Code for e2
    popl    %eax	# pop to eax (eax->eax)
    cmpl    $0, %eax
    movl    $0, %eax
    setne   %al
{end}:
"""

# AND, OR osv er egentlig LAND, LOR (LOGICAL)

		if obj.op.operator == "OR":
			clause = generateLabel()
			end = generateLabel()

			code += f"""\
    # Code for e1
    cmpl    $0, %eax
    je      {clause}
    movl    $1, %eax
    addl    $4, %esp
    jmp     {end}
{clause}:
	# Code for e2
    popl    %eax	# pop to eax (eax->eax)
    cmpl    $0, %eax
    movl    $0, %eax
    setne   %al
{end}:
"""

		if obj.op.operator == "EQUAL":
			code += """\
    cmpl    %eax, %ecx	# set ZF on if e1 =	= e2, set it off otherwise
    movl    $0, %eax	# zero out eax (doesn't change flags)
    sete    %al		# set al register (the lower byte of eax) to 1 if ZF is on
"""

		if obj.op.operator == 'NOT_EQUAL':
			code += """\
    cmpl    %eax, %ecx	# set ZF on if e1 == e2, set it off otherwise
    movl    $0, %eax	# zero out eax (doesn't change flags)
    setne   %al		# set al register (the lower byte of eax) to 1 if ZF is on
"""

		if obj.op.operator == 'LESS_THAN':
			code += """\
    cmpl    %eax, %ecx
    movl    $0, %eax
    setl    %al
"""

		if obj.op.operator == 'LESS_THAN_OR_EQUAL':
			code += """\
    cmpl    %eax, %ecx
    movl    $0, %eax
    setle   %al
"""

		if obj.op.operator == 'GREATER_THAN':
			code += """\
    cmpl    %eax, %ecx
    movl    $0, %eax
    setg    %al
"""

		if obj.op.operator == 'GREATER_THAN_OR_EQUAL':
			code += """\
    cmpl    %eax, %ecx
    movl    $0, %eax
	setge   %al
"""


	return code
#	assembly_format.format(ast.functions[0].body.statements[0].exp.value)

def main():
	arguments = parse_args()

	# Help if --help or no arguments
	if arguments.help or arguments.none:
		print(help_message)
		exit()

	# No input file
	if not arguments.infn:
		fail()

	# Infile doesn't exist
	if not os.path.isfile(arguments.infn):
		fail()

	tokens = lex(arguments.infn)

	ast = parse(tokens)

	# Pretty printing
	if arguments.pretty:
		pretty_print(ast)

	code = generate(ast)

	# Correct filenames to write to
	if arguments.asm and arguments.outfn:
		arguments.asmfn = arguments.outfn
	else:
		arguments.asmfn = os.path.splitext(arguments.infn)[0] + '.s'

	if (not arguments.asm) and (not arguments.outfn):
		arguments.outfn = 'a.out'

	# Write the generated assembly code to the file
	with open(arguments.asmfn, 'w') as asmfile:
		asmfile.write(code)

	# Assemble and delete temporary assembly file
	if not arguments.asm:
		os.system(f"gcc {arguments.asmfn} -m32 -g -o {arguments.outfn}")
		os.remove(arguments.asmfn)

if __name__ == "__main__":
	main()
